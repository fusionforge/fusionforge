#!/bin/sh
#---------------------------------------------------------------------------
# Novaforge is a registered trade mark from Bull S.A.S
# Copyright (C) 2007 Bull S.A.S.
# 
# http://novaforge.org/
#
#
# This file has been developped within the Novaforge(TM) project from Bull S.A.S
# and contributed back to GForge community.
#
# GForge is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# GForge is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this file; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#---------------------------------------------------------------------------

#
# Constants
#

PREFIX_CHAR="#"
BACKUP_CONFIG_DIR="%SYSCONFDIR%/%NAME%"
BACKUP_CONFIG_FILTER=".[a-z]*"
BACKUP_MYSQL_DIR="%LOCALSTATEDIR%/lib/mysql"
RESTORE_NAME="%NAME%_restore_`date +%Y-%m-%d_%H-%M-%S`"

#
# Variables
#

EXIT=0
TMP_DIR="/tmp"
BACKUP_DIR=""
BACKUP_FILE=""
MYSQLD_STOPPED=0

#
# Functions
#

# Remove unowned files and directories
# Parameters:
#   Directory, without ending /
remove_unowned ()
{
	TARGET=$1
	FILES=`find $TARGET/ | sort -r`
	for FILE in $FILES ; do
		if [ $FILE != $TARGET/ ] ; then
			rpm -qf $FILE >> /dev/null 2>&1
			if [ $? -ne 0 ] ; then
				if [ -d $FILE -a ! -L $FILE ] ; then
					rmdir $FILE
				else
					rm -f $FILE
				fi
			fi
		fi
	done
}

# Restore the content of a directory
# Parameters:
#   Source directory, without ending /
#   Files filter
#   Target directory, without ending /
#   Empty target directory (0/1)
copy_directory_content ()
{
	SOURCE=$1
	FILTER=$2
	TARGET=$3
	EMPTY=$4
	if [ $EXIT -eq 0 ] ; then
		echo -e "$PREFIX_CHAR Copying '$SOURCE/$FILTER' to '$TARGET/'"
		if [ -d $SOURCE ] ; then
			pushd $SOURCE >> /dev/null 2>&1
			if [ ! -e $TARGET ] ; then
				mkdir -p $TARGET
			fi
			if [ -d $TARGET -o -L $TARGET ] ; then
				NUMBER=`ls -a -1 | wc -l`
				expr $NUMBER \>= 2 > /dev/null 2>&1
				if [ $? -ne 0 ] ; then
					echo -e "$PREFIX_CHAR -> Error while checking if source directory is empty"
					EXIT=1
				else
					if [ $EMPTY -eq 1 ] ; then
						remove_unowned $TARGET
					fi
					if [ $EXIT -eq 0 ] ; then
						expr $NUMBER = 2 > /dev/null 2>&1
						if [ $? -eq 0 ] ; then
							echo -e "$PREFIX_CHAR -> Source directory is empty"
						else
							cp -af $FILTER $TARGET/
							if [ $? -ne 0 ] ; then
								echo -e "$PREFIX_CHAR -> Error while copying"
								EXIT=1
							fi
						fi
					fi
				fi
			else
				echo -e "$PREFIX_CHAR -> Error while creating target directory '$TARGET'"
				EXIT=1
			fi
			popd >> /dev/null 2>&1
		else
			echo -e "$PREFIX_CHAR -> Source directory '$1' does not exist"
			EXIT=1
		fi
	fi
}

# Stop a service
# Parameters:
#   Service name
stop_service ()
{
	SERVICE_NAME=$1
	echo -e "$PREFIX_CHAR Stopping service $SERVICE_NAME"
	if [ -x %INITRDDIR%/$SERVICE_NAME ] ; then
		service $SERVICE_NAME stop >> /dev/null 2>&1
		if [ $? -ne 0 ] ; then
			echo -e "$PREFIX_CHAR -> Error while stopping"
		fi
	else
		echo -e "$PREFIX_CHAR -> Script '%INITRDDIR%/$SERVICE_NAME' does not exist"
		EXIT=1
	fi
}

# Start a service
# Parameters:
#   Service name
start_service ()
{
	SERVICE_NAME=$1
	echo -e "$PREFIX_CHAR Restarting service $SERVICE_NAME"
	if [ -x %INITRDDIR%/$SERVICE_NAME ] ; then
		service $SERVICE_NAME start >> /dev/null 2>&1
		if [ $? -ne 0 ] ; then
			echo -e "$PREFIX_CHAR -> Error while starting"
			EXIT=1
		fi
	else
		echo -e "$PREFIX_CHAR -> Script '%INITRDDIR%/$SERVICE_NAME' does not exist"
		EXIT=1
	fi
}

#
# Main script
#

echo -e "$PREFIX_CHAR$PREFIX_CHAR"
echo -e "$PREFIX_CHAR %FRIENDLY_NAME% : restore data"
echo -e "$PREFIX_CHAR"
echo -e "$PREFIX_CHAR This script will restore data from an archive file."
echo -e "$PREFIX_CHAR -> Continue ('y' or 'n') ?"
echo -en "$PREFIX_CHAR -> "
read CHOICE
if [ "$CHOICE" != "y" ]; then
        exit 1
fi
#
# Ask temporary directory
#
if [ $EXIT -eq 0 ] ; then
	echo -e "$PREFIX_CHAR Please type the temporary directory (default: '$TMP_DIR', 'q' to quit)"
	echo -en "$PREFIX_CHAR -> "
	read CHOICE
	if [ "$CHOICE" = "q" ] ; then
		EXIT=1
	else
		if [ -n "$CHOICE" ]; then
			TMP_DIR=$CHOICE
		fi
		if [ ! -e $TMP_DIR ] ; then
			echo -e "$PREFIX_CHAR -> Directory '$TMP_DIR' does not exist"
			EXIT=1
		else
			if [ ! -d $TMP_DIR -a ! -L $TMP_DIR ] ; then
				echo -e "$PREFIX_CHAR -> '$TMP_DIR' is not a directory or a symbolic link"
				EXIT=1
			else
				BACKUP_DIR="$TMP_DIR/$RESTORE_NAME"
				export TMP=$TMP_DIR
			fi
		fi
	fi
fi
#
# Ask backup filename
#
if [ $EXIT -eq 0 ] ; then
	echo -e "$PREFIX_CHAR Please type the backup filename with its full path ('q' to quit)"
	echo -en "$PREFIX_CHAR -> "
	read CHOICE
	if [ "$CHOICE" = "q" ] ; then
		EXIT=1
	else
		if [ -n "$CHOICE" ]; then
			if [ -e $CHOICE ] ; then
				if [ -f $CHOICE ] ; then
					BACKUP_FILE=$CHOICE
				else
					echo -e "$PREFIX_CHAR -> '$CHOICE' is not a regular file"
					EXIT=1
				fi
			else
				echo -e "$PREFIX_CHAR -> File '$CHOICE' does not exist"
				EXIT=1
			fi
		else
			echo -e "$PREFIX_CHAR -> Backup filename is empty"
			EXIT=1
		fi
	fi
fi
#
# Confirm apocalypse
#
if [ $EXIT -eq 0 ] ; then
	echo -e "$PREFIX_CHAR Do you want to REPLACE CURRENT DATA with"
	echo -e "$PREFIX_CHAR content from file '$BACKUP_FILE' ('y' or 'n') ?"
	echo -en "$PREFIX_CHAR -> "
	read CHOICE
	if [ "$CHOICE" != "y" ]; then
		EXIT=1
	fi
fi
#
# Extract backup
#
if [ $EXIT -eq 0 ] ; then
	echo -e "$PREFIX_CHAR Extracting backup"
	mkdir $BACKUP_DIR >> /dev/null 2>&1
	if [ $? -ne 0 ] ; then
		echo -e "$PREFIX_CHAR -> Error while creating directory '$BACKUP_DIR'"
		EXIT=1
	fi
fi
if [ $EXIT -eq 0 ] ; then
	pushd $BACKUP_DIR >> /dev/null 2>&1
	tar -xzf $BACKUP_FILE >> /dev/null 2>&1
	if [ $? -ne 0 ] ; then
		echo -e "$PREFIX_CHAR -> Error while extracting to directory '$BACKUP_DIR'"
		EXIT=1
	else
		if [ -f VERSION ] ; then
			VERSION=`cat VERSION`
			if [ "$VERSION" != "%MANTIS_CUSTOM_LEVEL%" ] ; then
				echo -e "$PREFIX_CHAR -> Versions differs ($VERSION != %MANTIS_CUSTOM_LEVEL%), do you want to continue ('y' or 'n') ?"
				echo -en "$PREFIX_CHAR -> "
				read CHOICE
				if [ "$CHOICE" != "y" ] ; then
					EXIT=1
				fi
			fi
		else
			echo -e "$PREFIX_CHAR -> Version file is missing"
			EXIT=1
		fi
		if [ $EXIT -eq 0 ] ; then
			if [ -f DB_NAME ] ; then
				DB_NAME=`cat DB_NAME`
				if [ -z "$DB_NAME" ] ; then
					echo -e "$PREFIX_CHAR -> Database name file is empty"
					EXIT=1
				fi
			else
				echo -e "$PREFIX_CHAR -> Database name file is missing"
				EXIT=1
			fi
		fi
	fi
	popd >> /dev/null 2>&1
fi
#
# Stop mysqld service
#
if [ $EXIT -eq 0 ] ; then
	stop_service mysqld
	if [ $EXIT -eq 0 ] ; then
		MYSQLD_STOPPED=1
	fi
fi
#
# Restore files
#
copy_directory_content $BACKUP_DIR/config "$BACKUP_CONFIG_FILTER" $BACKUP_CONFIG_DIR 0
copy_directory_content $BACKUP_DIR/database "*" $BACKUP_MYSQL_DIR/$DB_NAME 1
#
# Start mysqld service
#
if [ $MYSQLD_STOPPED -eq 1 ] ; then
	start_service mysqld
fi
#
# Remove backup directory
#
if [ -d $BACKUP_DIR ] ; then
	echo -e "$PREFIX_CHAR Removing backup directory"
	rm -rf $BACKUP_DIR
fi
echo -e "$PREFIX_CHAR"
if [ $EXIT -eq 0 ] ; then
	echo -e "$PREFIX_CHAR -> Success !"
	echo -e "$PREFIX_CHAR"
	echo -e "$PREFIX_CHAR You should now run '%NAME%-config' to configure %FRIENDLY_NAME%."
	echo -e "$PREFIX_CHAR"
	echo -e "$PREFIX_CHAR Please note:"
	echo -e "$PREFIX_CHAR   * file '%SYSCONFDIR%/%NAME%/.admin' contains the cleartext password of %FRIENDLY_NAME% administrator 'admin'."
else
	echo -e "$PREFIX_CHAR -> Failure !"
fi
echo -e "$PREFIX_CHAR$PREFIX_CHAR"
exit $EXIT
