/* soapC.cpp
   Generated by gSOAP 2.3 rev 1 from SoapAPI.h
   Copyright (C) 2001-2003 Genivia inc.
   All Rights Reserved.
*/
#include "soapH.h"

SOAP_BEGIN_NAMESPACE(soap)

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.3 rev 1 2003-08-03 13:30:10 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL);
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	return soap_out_SOAP_ENV__Fault(soap, "SOAP-ENV:Fault", 0, soap->fault, NULL);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_in_SOAP_ENV__Fault(soap, "SOAP-ENV:Fault", NULL, NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Detail;
	return (const char**)&soap->fault->detail;
}

#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}

SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_tns__getNumberOfHostedProjectsResponse:
		return soap_in_tns__getNumberOfHostedProjectsResponse(soap, NULL, NULL, "tns:getNumberOfHostedProjectsResponse");
	case SOAP_TYPE_tns__helloResponse:
		return soap_in_tns__helloResponse(soap, NULL, NULL, "tns:helloResponse");
	case SOAP_TYPE_tns__bugAddResponse:
		return soap_in_tns__bugAddResponse(soap, NULL, NULL, "tns:bugAddResponse");
	case SOAP_TYPE_tns__bugListResponse:
		return soap_in_tns__bugListResponse(soap, NULL, NULL, "tns:bugListResponse");
	case SOAP_TYPE_tns__SiteStatsDataPoint:
		return soap_in_tns__SiteStatsDataPoint(soap, NULL, NULL, "tns:SiteStatsDataPoint");
	case SOAP_TYPE_tns__loginResponse:
		return soap_in_tns__loginResponse(soap, NULL, NULL, "tns:loginResponse");
	case SOAP_TYPE_tns__groupResponse:
		return soap_in_tns__groupResponse(soap, NULL, NULL, "tns:groupResponse");
	case SOAP_TYPE_tns__getNumberOfActiveUsersResponse:
		return soap_in_tns__getNumberOfActiveUsersResponse(soap, NULL, NULL, "tns:getNumberOfActiveUsersResponse");
	case SOAP_TYPE_ArrayOfGroupObject:
		return soap_in_ArrayOfGroupObject(soap, NULL, NULL, "tns:GroupObject");
	case SOAP_TYPE_ArrayOfBug:
		return soap_in_ArrayOfBug(soap, NULL, NULL, "tns:Bug");
	case SOAP_TYPE_tns__GroupObject:
		return soap_in_tns__GroupObject(soap, NULL, NULL, "tns:GroupObject");
	case SOAP_TYPE_ArrayOfSiteStatsDataPoint:
		return soap_in_ArrayOfSiteStatsDataPoint(soap, NULL, NULL, "tns:SiteStatsDataPoint");
	case SOAP_TYPE_tns__getSiteStatsResponse:
		return soap_in_tns__getSiteStatsResponse(soap, NULL, NULL, "tns:getSiteStatsResponse");
	case SOAP_TYPE_tns__getPublicProjectNamesResponse:
		return soap_in_tns__getPublicProjectNamesResponse(soap, NULL, NULL, "tns:getPublicProjectNamesResponse");
	case SOAP_TYPE_tns__logoutResponse:
		return soap_in_tns__logoutResponse(soap, NULL, NULL, "tns:logoutResponse");
	case SOAP_TYPE_tns__Bug:
		return soap_in_tns__Bug(soap, NULL, NULL, "tns:Bug");
	case SOAP_TYPE_tns__bugFetchResponse:
		return soap_in_tns__bugFetchResponse(soap, NULL, NULL, "tns:bugFetchResponse");
	case SOAP_TYPE_tns__ArrayOfstring:
		return soap_in_tns__ArrayOfstring(soap, NULL, NULL, "tns:ArrayOfstring");
	case SOAP_TYPE_tns__userResponse:
		return soap_in_tns__userResponse(soap, NULL, NULL, "tns:userResponse");
	case SOAP_TYPE_tns__bugUpdateResponse:
		return soap_in_tns__bugUpdateResponse(soap, NULL, NULL, "tns:bugUpdateResponse");
	case SOAP_TYPE_tns__bugFetch:
		return soap_in_tns__bugFetch(soap, NULL, NULL, "tns:bugFetch");
	case SOAP_TYPE_tns__getNumberOfHostedProjects:
		return soap_in_tns__getNumberOfHostedProjects(soap, NULL, NULL, "tns:getNumberOfHostedProjects");
	case SOAP_TYPE_tns__bugAdd:
		return soap_in_tns__bugAdd(soap, NULL, NULL, "tns:bugAdd");
	case SOAP_TYPE_tns__login:
		return soap_in_tns__login(soap, NULL, NULL, "tns:login");
	case SOAP_TYPE_tns__getSiteStats:
		return soap_in_tns__getSiteStats(soap, NULL, NULL, "tns:getSiteStats");
	case SOAP_TYPE_tns__getPublicProjectNames:
		return soap_in_tns__getPublicProjectNames(soap, NULL, NULL, "tns:getPublicProjectNames");
	case SOAP_TYPE_tns__group:
		return soap_in_tns__group(soap, NULL, NULL, "tns:group");
	case SOAP_TYPE_tns__bugUpdate:
		return soap_in_tns__bugUpdate(soap, NULL, NULL, "tns:bugUpdate");
	case SOAP_TYPE_tns__bugList:
		return soap_in_tns__bugList(soap, NULL, NULL, "tns:bugList");
	case SOAP_TYPE_tns__getNumberOfActiveUsers:
		return soap_in_tns__getNumberOfActiveUsers(soap, NULL, NULL, "tns:getNumberOfActiveUsers");
	case SOAP_TYPE_tns__hello:
		return soap_in_tns__hello(soap, NULL, NULL, "tns:hello");
	case SOAP_TYPE_tns__logout:
		return soap_in_tns__logout(soap, NULL, NULL, "tns:logout");
	case SOAP_TYPE_tns__user:
		return soap_in_tns__user(soap, NULL, NULL, "tns:user");
	case SOAP_TYPE_PointerTotns__bugFetchResponse:
		return soap_in_PointerTotns__bugFetchResponse(soap, NULL, NULL, "tns:bugFetchResponse");
	case SOAP_TYPE_PointerTotns__getNumberOfHostedProjectsResponse:
		return soap_in_PointerTotns__getNumberOfHostedProjectsResponse(soap, NULL, NULL, "tns:getNumberOfHostedProjectsResponse");
	case SOAP_TYPE_PointerTotns__bugAddResponse:
		return soap_in_PointerTotns__bugAddResponse(soap, NULL, NULL, "tns:bugAddResponse");
	case SOAP_TYPE_PointerTotns__loginResponse:
		return soap_in_PointerTotns__loginResponse(soap, NULL, NULL, "tns:loginResponse");
	case SOAP_TYPE_PointerTotns__getSiteStatsResponse:
		return soap_in_PointerTotns__getSiteStatsResponse(soap, NULL, NULL, "tns:getSiteStatsResponse");
	case SOAP_TYPE_PointerTotns__getPublicProjectNamesResponse:
		return soap_in_PointerTotns__getPublicProjectNamesResponse(soap, NULL, NULL, "tns:getPublicProjectNamesResponse");
	case SOAP_TYPE_PointerTotns__groupResponse:
		return soap_in_PointerTotns__groupResponse(soap, NULL, NULL, "tns:groupResponse");
	case SOAP_TYPE_PointerTotns__bugUpdateResponse:
		return soap_in_PointerTotns__bugUpdateResponse(soap, NULL, NULL, "tns:bugUpdateResponse");
	case SOAP_TYPE_PointerTotns__bugListResponse:
		return soap_in_PointerTotns__bugListResponse(soap, NULL, NULL, "tns:bugListResponse");
	case SOAP_TYPE_PointerTotns__getNumberOfActiveUsersResponse:
		return soap_in_PointerTotns__getNumberOfActiveUsersResponse(soap, NULL, NULL, "tns:getNumberOfActiveUsersResponse");
	case SOAP_TYPE_PointerTotns__helloResponse:
		return soap_in_PointerTotns__helloResponse(soap, NULL, NULL, "tns:helloResponse");
	case SOAP_TYPE_PointerTotns__logoutResponse:
		return soap_in_PointerTotns__logoutResponse(soap, NULL, NULL, "tns:logoutResponse");
	case SOAP_TYPE_PointerTotns__userResponse:
		return soap_in_PointerTotns__userResponse(soap, NULL, NULL, "tns:userResponse");
	case SOAP_TYPE_PointerTotns__SiteStatsDataPoint:
		return soap_in_PointerTotns__SiteStatsDataPoint(soap, NULL, NULL, "tns:SiteStatsDataPoint");
	case SOAP_TYPE_PointerToArrayOfGroupObject:
		return soap_in_PointerToArrayOfGroupObject(soap, NULL, NULL, "tns:GroupObject");
	case SOAP_TYPE_PointerTotns__GroupObject:
		return soap_in_PointerTotns__GroupObject(soap, NULL, NULL, "tns:GroupObject");
	case SOAP_TYPE_PointerToArrayOfSiteStatsDataPoint:
		return soap_in_PointerToArrayOfSiteStatsDataPoint(soap, NULL, NULL, "tns:SiteStatsDataPoint");
	case SOAP_TYPE_PointerTotns__Bug:
		return soap_in_PointerTotns__Bug(soap, NULL, NULL, "tns:Bug");
	case SOAP_TYPE_PointerTotns__ArrayOfstring:
		return soap_in_PointerTotns__ArrayOfstring(soap, NULL, NULL, "tns:ArrayOfstring");
	case SOAP_TYPE_xsd__string:
	{	char **s;
		s = soap_in_xsd__string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__integer:
	{	char **s;
		s = soap_in_xsd__integer(soap, NULL, NULL, "xsd:integer");
		return s ? *s : NULL;
	}
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
		if (!*soap->type)
			return NULL;
		if (!soap_match_tag(soap, soap->type, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tns:getNumberOfHostedProjectsResponse"))
		{	*type = SOAP_TYPE_tns__getNumberOfHostedProjectsResponse;
			return soap_in_tns__getNumberOfHostedProjectsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tns:helloResponse"))
		{	*type = SOAP_TYPE_tns__helloResponse;
			return soap_in_tns__helloResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tns:bugAddResponse"))
		{	*type = SOAP_TYPE_tns__bugAddResponse;
			return soap_in_tns__bugAddResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tns:bugListResponse"))
		{	*type = SOAP_TYPE_tns__bugListResponse;
			return soap_in_tns__bugListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tns:SiteStatsDataPoint"))
		{	*type = SOAP_TYPE_tns__SiteStatsDataPoint;
			return soap_in_tns__SiteStatsDataPoint(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tns:loginResponse"))
		{	*type = SOAP_TYPE_tns__loginResponse;
			return soap_in_tns__loginResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tns:groupResponse"))
		{	*type = SOAP_TYPE_tns__groupResponse;
			return soap_in_tns__groupResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tns:getNumberOfActiveUsersResponse"))
		{	*type = SOAP_TYPE_tns__getNumberOfActiveUsersResponse;
			return soap_in_tns__getNumberOfActiveUsersResponse(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "tns:GroupObject"))
		{	*type = SOAP_TYPE_ArrayOfGroupObject;
			return soap_in_ArrayOfGroupObject(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "tns:Bug"))
		{	*type = SOAP_TYPE_ArrayOfBug;
			return soap_in_ArrayOfBug(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tns:GroupObject"))
		{	*type = SOAP_TYPE_tns__GroupObject;
			return soap_in_tns__GroupObject(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "tns:SiteStatsDataPoint"))
		{	*type = SOAP_TYPE_ArrayOfSiteStatsDataPoint;
			return soap_in_ArrayOfSiteStatsDataPoint(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tns:getSiteStatsResponse"))
		{	*type = SOAP_TYPE_tns__getSiteStatsResponse;
			return soap_in_tns__getSiteStatsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tns:getPublicProjectNamesResponse"))
		{	*type = SOAP_TYPE_tns__getPublicProjectNamesResponse;
			return soap_in_tns__getPublicProjectNamesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tns:logoutResponse"))
		{	*type = SOAP_TYPE_tns__logoutResponse;
			return soap_in_tns__logoutResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tns:Bug"))
		{	*type = SOAP_TYPE_tns__Bug;
			return soap_in_tns__Bug(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tns:bugFetchResponse"))
		{	*type = SOAP_TYPE_tns__bugFetchResponse;
			return soap_in_tns__bugFetchResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tns:ArrayOfstring"))
		{	*type = SOAP_TYPE_tns__ArrayOfstring;
			return soap_in_tns__ArrayOfstring(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tns:userResponse"))
		{	*type = SOAP_TYPE_tns__userResponse;
			return soap_in_tns__userResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tns:bugUpdateResponse"))
		{	*type = SOAP_TYPE_tns__bugUpdateResponse;
			return soap_in_tns__bugUpdateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tns:bugFetch"))
		{	*type = SOAP_TYPE_tns__bugFetch;
			return soap_in_tns__bugFetch(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tns:getNumberOfHostedProjects"))
		{	*type = SOAP_TYPE_tns__getNumberOfHostedProjects;
			return soap_in_tns__getNumberOfHostedProjects(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tns:bugAdd"))
		{	*type = SOAP_TYPE_tns__bugAdd;
			return soap_in_tns__bugAdd(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tns:login"))
		{	*type = SOAP_TYPE_tns__login;
			return soap_in_tns__login(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tns:getSiteStats"))
		{	*type = SOAP_TYPE_tns__getSiteStats;
			return soap_in_tns__getSiteStats(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tns:getPublicProjectNames"))
		{	*type = SOAP_TYPE_tns__getPublicProjectNames;
			return soap_in_tns__getPublicProjectNames(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tns:group"))
		{	*type = SOAP_TYPE_tns__group;
			return soap_in_tns__group(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tns:bugUpdate"))
		{	*type = SOAP_TYPE_tns__bugUpdate;
			return soap_in_tns__bugUpdate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tns:bugList"))
		{	*type = SOAP_TYPE_tns__bugList;
			return soap_in_tns__bugList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tns:getNumberOfActiveUsers"))
		{	*type = SOAP_TYPE_tns__getNumberOfActiveUsers;
			return soap_in_tns__getNumberOfActiveUsers(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tns:hello"))
		{	*type = SOAP_TYPE_tns__hello;
			return soap_in_tns__hello(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tns:logout"))
		{	*type = SOAP_TYPE_tns__logout;
			return soap_in_tns__logout(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tns:user"))
		{	*type = SOAP_TYPE_tns__user;
			return soap_in_tns__user(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_xsd__string;
			s = soap_in_xsd__string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, soap->type, "xsd:integer"))
		{	char **s;
			*type = SOAP_TYPE_xsd__integer;
			s = soap_in_xsd__integer(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, soap->type, "QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, soap->type, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	return NULL;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{	if (soap->mode & SOAP_XML_STRICT)
		return SOAP_TAG_MISMATCH;
	if (!soap_peek_element(soap))
	{	int t;
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unknown element '%s' (level=%u, %d)\n", soap->tag, soap->level, soap->body));
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;}

SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if ((soap->mode & SOAP_IO_LENGTH) ? pp->mark1 == 2 : pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_tns__getNumberOfHostedProjectsResponse:
		return ((tns__getNumberOfHostedProjectsResponse *)ptr)->soap_out(soap, tag, id, "tns:getNumberOfHostedProjectsResponse");
	case SOAP_TYPE_tns__helloResponse:
		return ((tns__helloResponse *)ptr)->soap_out(soap, tag, id, "tns:helloResponse");
	case SOAP_TYPE_tns__bugAddResponse:
		return ((tns__bugAddResponse *)ptr)->soap_out(soap, tag, id, "tns:bugAddResponse");
	case SOAP_TYPE_tns__bugListResponse:
		return ((tns__bugListResponse *)ptr)->soap_out(soap, tag, id, "tns:bugListResponse");
	case SOAP_TYPE_tns__SiteStatsDataPoint:
		return ((tns__SiteStatsDataPoint *)ptr)->soap_out(soap, tag, id, "tns:SiteStatsDataPoint");
	case SOAP_TYPE_tns__loginResponse:
		return ((tns__loginResponse *)ptr)->soap_out(soap, tag, id, "tns:loginResponse");
	case SOAP_TYPE_tns__groupResponse:
		return ((tns__groupResponse *)ptr)->soap_out(soap, tag, id, "tns:groupResponse");
	case SOAP_TYPE_tns__getNumberOfActiveUsersResponse:
		return ((tns__getNumberOfActiveUsersResponse *)ptr)->soap_out(soap, tag, id, "tns:getNumberOfActiveUsersResponse");
	case SOAP_TYPE_ArrayOfGroupObject:
		return ((ArrayOfGroupObject *)ptr)->soap_out(soap, tag, id, "tns:GroupObject");
	case SOAP_TYPE_ArrayOfBug:
		return ((ArrayOfBug *)ptr)->soap_out(soap, tag, id, "tns:Bug");
	case SOAP_TYPE_tns__GroupObject:
		return ((tns__GroupObject *)ptr)->soap_out(soap, tag, id, "tns:GroupObject");
	case SOAP_TYPE_ArrayOfSiteStatsDataPoint:
		return ((ArrayOfSiteStatsDataPoint *)ptr)->soap_out(soap, tag, id, "tns:SiteStatsDataPoint");
	case SOAP_TYPE_tns__getSiteStatsResponse:
		return ((tns__getSiteStatsResponse *)ptr)->soap_out(soap, tag, id, "tns:getSiteStatsResponse");
	case SOAP_TYPE_tns__getPublicProjectNamesResponse:
		return ((tns__getPublicProjectNamesResponse *)ptr)->soap_out(soap, tag, id, "tns:getPublicProjectNamesResponse");
	case SOAP_TYPE_tns__logoutResponse:
		return ((tns__logoutResponse *)ptr)->soap_out(soap, tag, id, "tns:logoutResponse");
	case SOAP_TYPE_tns__Bug:
		return ((tns__Bug *)ptr)->soap_out(soap, tag, id, "tns:Bug");
	case SOAP_TYPE_tns__bugFetchResponse:
		return ((tns__bugFetchResponse *)ptr)->soap_out(soap, tag, id, "tns:bugFetchResponse");
	case SOAP_TYPE_tns__ArrayOfstring:
		return ((tns__ArrayOfstring *)ptr)->soap_out(soap, tag, id, "tns:ArrayOfstring");
	case SOAP_TYPE_tns__userResponse:
		return ((tns__userResponse *)ptr)->soap_out(soap, tag, id, "tns:userResponse");
	case SOAP_TYPE_tns__bugUpdateResponse:
		return ((tns__bugUpdateResponse *)ptr)->soap_out(soap, tag, id, "tns:bugUpdateResponse");
	case SOAP_TYPE_tns__bugFetch:
		return soap_out_tns__bugFetch(soap, tag, id, (const struct tns__bugFetch *)ptr, "tns:bugFetch");
	case SOAP_TYPE_tns__getNumberOfHostedProjects:
		return soap_out_tns__getNumberOfHostedProjects(soap, tag, id, (const struct tns__getNumberOfHostedProjects *)ptr, "tns:getNumberOfHostedProjects");
	case SOAP_TYPE_tns__bugAdd:
		return soap_out_tns__bugAdd(soap, tag, id, (const struct tns__bugAdd *)ptr, "tns:bugAdd");
	case SOAP_TYPE_tns__login:
		return soap_out_tns__login(soap, tag, id, (const struct tns__login *)ptr, "tns:login");
	case SOAP_TYPE_tns__getSiteStats:
		return soap_out_tns__getSiteStats(soap, tag, id, (const struct tns__getSiteStats *)ptr, "tns:getSiteStats");
	case SOAP_TYPE_tns__getPublicProjectNames:
		return soap_out_tns__getPublicProjectNames(soap, tag, id, (const struct tns__getPublicProjectNames *)ptr, "tns:getPublicProjectNames");
	case SOAP_TYPE_tns__group:
		return soap_out_tns__group(soap, tag, id, (const struct tns__group *)ptr, "tns:group");
	case SOAP_TYPE_tns__bugUpdate:
		return soap_out_tns__bugUpdate(soap, tag, id, (const struct tns__bugUpdate *)ptr, "tns:bugUpdate");
	case SOAP_TYPE_tns__bugList:
		return soap_out_tns__bugList(soap, tag, id, (const struct tns__bugList *)ptr, "tns:bugList");
	case SOAP_TYPE_tns__getNumberOfActiveUsers:
		return soap_out_tns__getNumberOfActiveUsers(soap, tag, id, (const struct tns__getNumberOfActiveUsers *)ptr, "tns:getNumberOfActiveUsers");
	case SOAP_TYPE_tns__hello:
		return soap_out_tns__hello(soap, tag, id, (const struct tns__hello *)ptr, "tns:hello");
	case SOAP_TYPE_tns__logout:
		return soap_out_tns__logout(soap, tag, id, (const struct tns__logout *)ptr, "tns:logout");
	case SOAP_TYPE_tns__user:
		return soap_out_tns__user(soap, tag, id, (const struct tns__user *)ptr, "tns:user");
	case SOAP_TYPE_PointerTotns__bugFetchResponse:
		return soap_out_PointerTotns__bugFetchResponse(soap, tag, id, (tns__bugFetchResponse *const*)ptr, "tns:bugFetchResponse");
	case SOAP_TYPE_PointerTotns__getNumberOfHostedProjectsResponse:
		return soap_out_PointerTotns__getNumberOfHostedProjectsResponse(soap, tag, id, (tns__getNumberOfHostedProjectsResponse *const*)ptr, "tns:getNumberOfHostedProjectsResponse");
	case SOAP_TYPE_PointerTotns__bugAddResponse:
		return soap_out_PointerTotns__bugAddResponse(soap, tag, id, (tns__bugAddResponse *const*)ptr, "tns:bugAddResponse");
	case SOAP_TYPE_PointerTotns__loginResponse:
		return soap_out_PointerTotns__loginResponse(soap, tag, id, (tns__loginResponse *const*)ptr, "tns:loginResponse");
	case SOAP_TYPE_PointerTotns__getSiteStatsResponse:
		return soap_out_PointerTotns__getSiteStatsResponse(soap, tag, id, (tns__getSiteStatsResponse *const*)ptr, "tns:getSiteStatsResponse");
	case SOAP_TYPE_PointerTotns__getPublicProjectNamesResponse:
		return soap_out_PointerTotns__getPublicProjectNamesResponse(soap, tag, id, (tns__getPublicProjectNamesResponse *const*)ptr, "tns:getPublicProjectNamesResponse");
	case SOAP_TYPE_PointerTotns__groupResponse:
		return soap_out_PointerTotns__groupResponse(soap, tag, id, (tns__groupResponse *const*)ptr, "tns:groupResponse");
	case SOAP_TYPE_PointerTotns__bugUpdateResponse:
		return soap_out_PointerTotns__bugUpdateResponse(soap, tag, id, (tns__bugUpdateResponse *const*)ptr, "tns:bugUpdateResponse");
	case SOAP_TYPE_PointerTotns__bugListResponse:
		return soap_out_PointerTotns__bugListResponse(soap, tag, id, (tns__bugListResponse *const*)ptr, "tns:bugListResponse");
	case SOAP_TYPE_PointerTotns__getNumberOfActiveUsersResponse:
		return soap_out_PointerTotns__getNumberOfActiveUsersResponse(soap, tag, id, (tns__getNumberOfActiveUsersResponse *const*)ptr, "tns:getNumberOfActiveUsersResponse");
	case SOAP_TYPE_PointerTotns__helloResponse:
		return soap_out_PointerTotns__helloResponse(soap, tag, id, (tns__helloResponse *const*)ptr, "tns:helloResponse");
	case SOAP_TYPE_PointerTotns__logoutResponse:
		return soap_out_PointerTotns__logoutResponse(soap, tag, id, (tns__logoutResponse *const*)ptr, "tns:logoutResponse");
	case SOAP_TYPE_PointerTotns__userResponse:
		return soap_out_PointerTotns__userResponse(soap, tag, id, (tns__userResponse *const*)ptr, "tns:userResponse");
	case SOAP_TYPE_PointerTotns__SiteStatsDataPoint:
		return soap_out_PointerTotns__SiteStatsDataPoint(soap, tag, id, (tns__SiteStatsDataPoint *const*)ptr, "tns:SiteStatsDataPoint");
	case SOAP_TYPE_PointerToArrayOfGroupObject:
		return soap_out_PointerToArrayOfGroupObject(soap, tag, id, (ArrayOfGroupObject *const*)ptr, "tns:GroupObject");
	case SOAP_TYPE_PointerTotns__GroupObject:
		return soap_out_PointerTotns__GroupObject(soap, tag, id, (tns__GroupObject *const*)ptr, "tns:GroupObject");
	case SOAP_TYPE_PointerToArrayOfSiteStatsDataPoint:
		return soap_out_PointerToArrayOfSiteStatsDataPoint(soap, tag, id, (ArrayOfSiteStatsDataPoint *const*)ptr, "tns:SiteStatsDataPoint");
	case SOAP_TYPE_PointerTotns__Bug:
		return soap_out_PointerTotns__Bug(soap, tag, id, (tns__Bug *const*)ptr, "tns:Bug");
	case SOAP_TYPE_PointerTotns__ArrayOfstring:
		return soap_out_PointerTotns__ArrayOfstring(soap, tag, id, (tns__ArrayOfstring *const*)ptr, "tns:ArrayOfstring");
	case SOAP_TYPE_xsd__string:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:string");
	case SOAP_TYPE_xsd__integer:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:integer");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char**)&ptr, "QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifndef WITH_LEANER
SOAP_FMAC3 int SOAP_FMAC4 soap_getattachments(struct soap *soap)
{
	if (!(soap->mode & SOAP_ENC_DIME))
		return SOAP_OK;
	while (soap->dime_flags & SOAP_DIME_CF)
	{	if (soap_getdimehdr(soap))
			return soap->error;
		if (soap_move(soap, soap->dime_size))
			return soap->error = SOAP_EOF;
	}
	if (soap_move(soap, ((soap->dime_size+3)&(~3))-soap_tell(soap)))
		return soap->error = SOAP_EOF;
	for (;;)
	{	if (soap_getdime(soap) || !soap->dime_id)
			break;
		switch (soap_lookup_type(soap, soap->dime_id))
		{
		case SOAP_TYPE_xsd__string:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsd__string, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_xsd__integer:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsd__integer, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE__QName:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE__QName, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_string:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_string, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		default:
			soap->error = SOAP_DIME_ERROR;
		}
		if (soap->error)
			break;
	}
	if (soap->error == SOAP_EOD)
		soap->error = SOAP_OK;
	return soap->error;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putattachments(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (!(soap->mode & SOAP_ENC_DIME))
		return SOAP_OK;
	for (i = 0; i < SOAP_PTRHASH; i++)
		for (pp = soap->pht[i]; pp; pp = pp->next)
			if (pp->mark2 == 3)
				switch (pp->type)
				{
				}
		
	return SOAP_OK;
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_tns__bugUpdateResponse:
		return (void*)soap_instantiate_tns__bugUpdateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tns__userResponse:
		return (void*)soap_instantiate_tns__userResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tns__ArrayOfstring:
		return (void*)soap_instantiate_tns__ArrayOfstring(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tns__bugFetchResponse:
		return (void*)soap_instantiate_tns__bugFetchResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tns__logoutResponse:
		return (void*)soap_instantiate_tns__logoutResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tns__getPublicProjectNamesResponse:
		return (void*)soap_instantiate_tns__getPublicProjectNamesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tns__getSiteStatsResponse:
		return (void*)soap_instantiate_tns__getSiteStatsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tns__GroupObject:
		return (void*)soap_instantiate_tns__GroupObject(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfBug:
		return (void*)soap_instantiate_ArrayOfBug(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfGroupObject:
		return (void*)soap_instantiate_ArrayOfGroupObject(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tns__getNumberOfActiveUsersResponse:
		return (void*)soap_instantiate_tns__getNumberOfActiveUsersResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tns__groupResponse:
		return (void*)soap_instantiate_tns__groupResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tns__loginResponse:
		return (void*)soap_instantiate_tns__loginResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfSiteStatsDataPoint:
		return (void*)soap_instantiate_ArrayOfSiteStatsDataPoint(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tns__bugListResponse:
		return (void*)soap_instantiate_tns__bugListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tns__Bug:
		return (void*)soap_instantiate_tns__Bug(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tns__bugAddResponse:
		return (void*)soap_instantiate_tns__bugAddResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tns__helloResponse:
		return (void*)soap_instantiate_tns__helloResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tns__SiteStatsDataPoint:
		return (void*)soap_instantiate_tns__SiteStatsDataPoint(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tns__getNumberOfHostedProjectsResponse:
		return (void*)soap_instantiate_tns__getNumberOfHostedProjectsResponse(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_destroy(struct soap *soap)
{	soap_delete(soap, NULL);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_delete(struct soap *soap, void *p)
{
	struct soap_clist **cp;
	cp = &soap->clist;
	while (*cp)
	{	if (!p || p == (*cp)->ptr)
		{	struct soap_clist *q = *cp;
			*cp = q->next;
			switch (q->type)
			{
			case SOAP_TYPE_tns__bugUpdateResponse:
				DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_delete(tns__bugUpdateResponse, %d)\n", q->size));
				if (q->size < 0)
					delete (tns__bugUpdateResponse*)q->ptr;
				else
					delete[] (tns__bugUpdateResponse*)q->ptr;
				break;
			case SOAP_TYPE_tns__userResponse:
				DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_delete(tns__userResponse, %d)\n", q->size));
				if (q->size < 0)
					delete (tns__userResponse*)q->ptr;
				else
					delete[] (tns__userResponse*)q->ptr;
				break;
			case SOAP_TYPE_tns__ArrayOfstring:
				DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_delete(tns__ArrayOfstring, %d)\n", q->size));
				if (q->size < 0)
					delete (tns__ArrayOfstring*)q->ptr;
				else
					delete[] (tns__ArrayOfstring*)q->ptr;
				break;
			case SOAP_TYPE_tns__bugFetchResponse:
				DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_delete(tns__bugFetchResponse, %d)\n", q->size));
				if (q->size < 0)
					delete (tns__bugFetchResponse*)q->ptr;
				else
					delete[] (tns__bugFetchResponse*)q->ptr;
				break;
			case SOAP_TYPE_tns__logoutResponse:
				DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_delete(tns__logoutResponse, %d)\n", q->size));
				if (q->size < 0)
					delete (tns__logoutResponse*)q->ptr;
				else
					delete[] (tns__logoutResponse*)q->ptr;
				break;
			case SOAP_TYPE_tns__getPublicProjectNamesResponse:
				DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_delete(tns__getPublicProjectNamesResponse, %d)\n", q->size));
				if (q->size < 0)
					delete (tns__getPublicProjectNamesResponse*)q->ptr;
				else
					delete[] (tns__getPublicProjectNamesResponse*)q->ptr;
				break;
			case SOAP_TYPE_tns__getSiteStatsResponse:
				DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_delete(tns__getSiteStatsResponse, %d)\n", q->size));
				if (q->size < 0)
					delete (tns__getSiteStatsResponse*)q->ptr;
				else
					delete[] (tns__getSiteStatsResponse*)q->ptr;
				break;
			case SOAP_TYPE_tns__GroupObject:
				DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_delete(tns__GroupObject, %d)\n", q->size));
				if (q->size < 0)
					delete (tns__GroupObject*)q->ptr;
				else
					delete[] (tns__GroupObject*)q->ptr;
				break;
			case SOAP_TYPE_ArrayOfBug:
				DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_delete(ArrayOfBug, %d)\n", q->size));
				if (q->size < 0)
					delete (ArrayOfBug*)q->ptr;
				else
					delete[] (ArrayOfBug*)q->ptr;
				break;
			case SOAP_TYPE_ArrayOfGroupObject:
				DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_delete(ArrayOfGroupObject, %d)\n", q->size));
				if (q->size < 0)
					delete (ArrayOfGroupObject*)q->ptr;
				else
					delete[] (ArrayOfGroupObject*)q->ptr;
				break;
			case SOAP_TYPE_tns__getNumberOfActiveUsersResponse:
				DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_delete(tns__getNumberOfActiveUsersResponse, %d)\n", q->size));
				if (q->size < 0)
					delete (tns__getNumberOfActiveUsersResponse*)q->ptr;
				else
					delete[] (tns__getNumberOfActiveUsersResponse*)q->ptr;
				break;
			case SOAP_TYPE_tns__groupResponse:
				DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_delete(tns__groupResponse, %d)\n", q->size));
				if (q->size < 0)
					delete (tns__groupResponse*)q->ptr;
				else
					delete[] (tns__groupResponse*)q->ptr;
				break;
			case SOAP_TYPE_tns__loginResponse:
				DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_delete(tns__loginResponse, %d)\n", q->size));
				if (q->size < 0)
					delete (tns__loginResponse*)q->ptr;
				else
					delete[] (tns__loginResponse*)q->ptr;
				break;
			case SOAP_TYPE_ArrayOfSiteStatsDataPoint:
				DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_delete(ArrayOfSiteStatsDataPoint, %d)\n", q->size));
				if (q->size < 0)
					delete (ArrayOfSiteStatsDataPoint*)q->ptr;
				else
					delete[] (ArrayOfSiteStatsDataPoint*)q->ptr;
				break;
			case SOAP_TYPE_tns__bugListResponse:
				DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_delete(tns__bugListResponse, %d)\n", q->size));
				if (q->size < 0)
					delete (tns__bugListResponse*)q->ptr;
				else
					delete[] (tns__bugListResponse*)q->ptr;
				break;
			case SOAP_TYPE_tns__Bug:
				DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_delete(tns__Bug, %d)\n", q->size));
				if (q->size < 0)
					delete (tns__Bug*)q->ptr;
				else
					delete[] (tns__Bug*)q->ptr;
				break;
			case SOAP_TYPE_tns__bugAddResponse:
				DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_delete(tns__bugAddResponse, %d)\n", q->size));
				if (q->size < 0)
					delete (tns__bugAddResponse*)q->ptr;
				else
					delete[] (tns__bugAddResponse*)q->ptr;
				break;
			case SOAP_TYPE_tns__helloResponse:
				DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_delete(tns__helloResponse, %d)\n", q->size));
				if (q->size < 0)
					delete (tns__helloResponse*)q->ptr;
				else
					delete[] (tns__helloResponse*)q->ptr;
				break;
			case SOAP_TYPE_tns__SiteStatsDataPoint:
				DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_delete(tns__SiteStatsDataPoint, %d)\n", q->size));
				if (q->size < 0)
					delete (tns__SiteStatsDataPoint*)q->ptr;
				else
					delete[] (tns__SiteStatsDataPoint*)q->ptr;
				break;
			case SOAP_TYPE_tns__getNumberOfHostedProjectsResponse:
				DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_delete(tns__getNumberOfHostedProjectsResponse, %d)\n", q->size));
				if (q->size < 0)
					delete (tns__getNumberOfHostedProjectsResponse*)q->ptr;
				else
					delete[] (tns__getNumberOfHostedProjectsResponse*)q->ptr;
				break;
			default:
				DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not delete instance %p: memory leak?)\n", q->ptr));
			}
			SOAP_FREE(q);
			if (p)
				return;
			cp = &soap->clist;
		}
		else
			cp = &(*cp)->next;
	}
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	struct soap_ilist *ip;
	DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Class id enter id='%s' t=%d loc=%p type='%s' arrayType='%s'\n", id, t, p, type?type:"", arrayType?arrayType:""));
	soap->alloced = 0;
	if (!*id)
	{	if (!p)
			return soap_instantiate(soap, t, type, arrayType, NULL);
		else
			return p;
	}
	ip = soap_lookup(soap, id);
	if (!ip)
	{	ip = soap_enter(soap, id);
		ip->type = t;
		ip->link = NULL;
		ip->copy = NULL;
		ip->clist = NULL;
		if (!p)
			p = soap_instantiate(soap, t, type, arrayType, &n);
		ip->ptr = p;
		ip->size = n;
		ip->level = 0;
	}
	else if (ip->ptr)
	{	if (p)
		{	soap->error = SOAP_MULTI_ID;
			return NULL;
		}
	}
	else
	{	if (!p)
			p = soap_instantiate(soap, t, type, arrayType, &n);
		ip->ptr = p;
		ip->size = n;
		ip->level = 0;
		if (!soap->blist)
			soap_resolve_ptr(ip);
	}
	return ip->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_byte(struct soap *soap, char const*a)
{
	soap_reference(soap, a, SOAP_TYPE_byte);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, char *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_byte);
	soap_out_byte(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_int(struct soap *soap, int const*a)
{
	soap_reference(soap, a, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, int *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_int);
	soap_out_int(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
}

void tns__getNumberOfHostedProjectsResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_tns__getNumberOfHostedProjectsResponse))
		this->soap_mark(soap);
}

void tns__getNumberOfHostedProjectsResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((tns__getNumberOfHostedProjectsResponse*)this)->_hostedProjects, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((tns__getNumberOfHostedProjectsResponse*)this)->_hostedProjects);
}

void tns__getNumberOfHostedProjectsResponse::soap_default(struct soap *soap)
{
	soap_default_xsd__string(soap, &((tns__getNumberOfHostedProjectsResponse*)this)->_hostedProjects);
}

int tns__getNumberOfHostedProjectsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_tns__getNumberOfHostedProjectsResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int tns__getNumberOfHostedProjectsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__getNumberOfHostedProjectsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__getNumberOfHostedProjectsResponse(struct soap *soap, const char *tag, int id, const tns__getNumberOfHostedProjectsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__getNumberOfHostedProjectsResponse), "tns:getNumberOfHostedProjectsResponse");
	soap_out_xsd__string(soap, "hostedProjects", -1, &(((tns__getNumberOfHostedProjectsResponse*)a)->_hostedProjects), "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *tns__getNumberOfHostedProjectsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__getNumberOfHostedProjectsResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__getNumberOfHostedProjectsResponse * SOAP_FMAC4 soap_get_tns__getNumberOfHostedProjectsResponse(struct soap *soap, tns__getNumberOfHostedProjectsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__getNumberOfHostedProjectsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *tns__getNumberOfHostedProjectsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__getNumberOfHostedProjectsResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__getNumberOfHostedProjectsResponse * SOAP_FMAC4 soap_in_tns__getNumberOfHostedProjectsResponse(struct soap *soap, const char *tag, tns__getNumberOfHostedProjectsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (tns__getNumberOfHostedProjectsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__getNumberOfHostedProjectsResponse, sizeof(tns__getNumberOfHostedProjectsResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_tns__getNumberOfHostedProjectsResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (tns__getNumberOfHostedProjectsResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag__hostedProjects1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag__hostedProjects1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &(((tns__getNumberOfHostedProjectsResponse*)a)->_hostedProjects), "xsd:string"))
				{	soap_flag__hostedProjects1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (tns__getNumberOfHostedProjectsResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__getNumberOfHostedProjectsResponse, sizeof(tns__getNumberOfHostedProjectsResponse), soap->type, soap->arrayType), SOAP_TYPE_tns__getNumberOfHostedProjectsResponse, sizeof(tns__getNumberOfHostedProjectsResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 tns__getNumberOfHostedProjectsResponse * SOAP_FMAC4 soap_new_tns__getNumberOfHostedProjectsResponse(struct soap *soap, int n)
{	return soap_instantiate_tns__getNumberOfHostedProjectsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_delete_tns__getNumberOfHostedProjectsResponse(struct soap *soap, tns__getNumberOfHostedProjectsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 tns__getNumberOfHostedProjectsResponse * SOAP_FMAC4 soap_instantiate_tns__getNumberOfHostedProjectsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__getNumberOfHostedProjectsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tns__getNumberOfHostedProjectsResponse, n);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new tns__getNumberOfHostedProjectsResponse;
		if (size)
			*size = sizeof(tns__getNumberOfHostedProjectsResponse);
	}
	else
	{	cp->ptr = (void*)new tns__getNumberOfHostedProjectsResponse[n];
		if (size)
			*size = n * sizeof(tns__getNumberOfHostedProjectsResponse);
	}
	return (tns__getNumberOfHostedProjectsResponse*)cp->ptr;
}

void tns__helloResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_tns__helloResponse))
		this->soap_mark(soap);
}

void tns__helloResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((tns__helloResponse*)this)->_helloResponse, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((tns__helloResponse*)this)->_helloResponse);
}

void tns__helloResponse::soap_default(struct soap *soap)
{
	soap_default_xsd__string(soap, &((tns__helloResponse*)this)->_helloResponse);
}

int tns__helloResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_tns__helloResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int tns__helloResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__helloResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__helloResponse(struct soap *soap, const char *tag, int id, const tns__helloResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__helloResponse), "tns:helloResponse");
	soap_out_xsd__string(soap, "helloResponse", -1, &(((tns__helloResponse*)a)->_helloResponse), "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *tns__helloResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__helloResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__helloResponse * SOAP_FMAC4 soap_get_tns__helloResponse(struct soap *soap, tns__helloResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__helloResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *tns__helloResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__helloResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__helloResponse * SOAP_FMAC4 soap_in_tns__helloResponse(struct soap *soap, const char *tag, tns__helloResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (tns__helloResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__helloResponse, sizeof(tns__helloResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_tns__helloResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (tns__helloResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag__helloResponse1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag__helloResponse1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &(((tns__helloResponse*)a)->_helloResponse), "xsd:string"))
				{	soap_flag__helloResponse1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (tns__helloResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__helloResponse, sizeof(tns__helloResponse), soap->type, soap->arrayType), SOAP_TYPE_tns__helloResponse, sizeof(tns__helloResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 tns__helloResponse * SOAP_FMAC4 soap_new_tns__helloResponse(struct soap *soap, int n)
{	return soap_instantiate_tns__helloResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_delete_tns__helloResponse(struct soap *soap, tns__helloResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 tns__helloResponse * SOAP_FMAC4 soap_instantiate_tns__helloResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__helloResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tns__helloResponse, n);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new tns__helloResponse;
		if (size)
			*size = sizeof(tns__helloResponse);
	}
	else
	{	cp->ptr = (void*)new tns__helloResponse[n];
		if (size)
			*size = n * sizeof(tns__helloResponse);
	}
	return (tns__helloResponse*)cp->ptr;
}

void tns__bugAddResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_tns__bugAddResponse))
		this->soap_mark(soap);
}

void tns__bugAddResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((tns__bugAddResponse*)this)->_bugAddResponse, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((tns__bugAddResponse*)this)->_bugAddResponse);
}

void tns__bugAddResponse::soap_default(struct soap *soap)
{
	soap_default_xsd__string(soap, &((tns__bugAddResponse*)this)->_bugAddResponse);
}

int tns__bugAddResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_tns__bugAddResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int tns__bugAddResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__bugAddResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__bugAddResponse(struct soap *soap, const char *tag, int id, const tns__bugAddResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__bugAddResponse), "tns:bugAddResponse");
	soap_out_xsd__string(soap, "bugAddResponse", -1, &(((tns__bugAddResponse*)a)->_bugAddResponse), "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *tns__bugAddResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__bugAddResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__bugAddResponse * SOAP_FMAC4 soap_get_tns__bugAddResponse(struct soap *soap, tns__bugAddResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__bugAddResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *tns__bugAddResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__bugAddResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__bugAddResponse * SOAP_FMAC4 soap_in_tns__bugAddResponse(struct soap *soap, const char *tag, tns__bugAddResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (tns__bugAddResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__bugAddResponse, sizeof(tns__bugAddResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_tns__bugAddResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (tns__bugAddResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag__bugAddResponse1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag__bugAddResponse1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &(((tns__bugAddResponse*)a)->_bugAddResponse), "xsd:string"))
				{	soap_flag__bugAddResponse1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (tns__bugAddResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__bugAddResponse, sizeof(tns__bugAddResponse), soap->type, soap->arrayType), SOAP_TYPE_tns__bugAddResponse, sizeof(tns__bugAddResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 tns__bugAddResponse * SOAP_FMAC4 soap_new_tns__bugAddResponse(struct soap *soap, int n)
{	return soap_instantiate_tns__bugAddResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_delete_tns__bugAddResponse(struct soap *soap, tns__bugAddResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 tns__bugAddResponse * SOAP_FMAC4 soap_instantiate_tns__bugAddResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__bugAddResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tns__bugAddResponse, n);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new tns__bugAddResponse;
		if (size)
			*size = sizeof(tns__bugAddResponse);
	}
	else
	{	cp->ptr = (void*)new tns__bugAddResponse[n];
		if (size)
			*size = n * sizeof(tns__bugAddResponse);
	}
	return (tns__bugAddResponse*)cp->ptr;
}

void tns__bugListResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_tns__bugListResponse))
		this->soap_mark(soap);
}

void tns__bugListResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((tns__bugListResponse*)this)->_bugListResponse, SOAP_TYPE_PointerTotns__ArrayOfstring);
	soap_mark_PointerTotns__ArrayOfstring(soap, &((tns__bugListResponse*)this)->_bugListResponse);
}

void tns__bugListResponse::soap_default(struct soap *soap)
{
	soap_default_PointerTotns__ArrayOfstring(soap, &((tns__bugListResponse*)this)->_bugListResponse);
}

int tns__bugListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_tns__bugListResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int tns__bugListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__bugListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__bugListResponse(struct soap *soap, const char *tag, int id, const tns__bugListResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__bugListResponse), "tns:bugListResponse");
	soap_out_PointerTotns__ArrayOfstring(soap, "bugListResponse", -1, &(((tns__bugListResponse*)a)->_bugListResponse), "tns:ArrayOfstring");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *tns__bugListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__bugListResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__bugListResponse * SOAP_FMAC4 soap_get_tns__bugListResponse(struct soap *soap, tns__bugListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__bugListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *tns__bugListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__bugListResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__bugListResponse * SOAP_FMAC4 soap_in_tns__bugListResponse(struct soap *soap, const char *tag, tns__bugListResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (tns__bugListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__bugListResponse, sizeof(tns__bugListResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_tns__bugListResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (tns__bugListResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag__bugListResponse1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag__bugListResponse1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__ArrayOfstring(soap, NULL, &(((tns__bugListResponse*)a)->_bugListResponse), "tns:ArrayOfstring"))
				{	soap_flag__bugListResponse1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (tns__bugListResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__bugListResponse, sizeof(tns__bugListResponse), soap->type, soap->arrayType), SOAP_TYPE_tns__bugListResponse, sizeof(tns__bugListResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 tns__bugListResponse * SOAP_FMAC4 soap_new_tns__bugListResponse(struct soap *soap, int n)
{	return soap_instantiate_tns__bugListResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_delete_tns__bugListResponse(struct soap *soap, tns__bugListResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 tns__bugListResponse * SOAP_FMAC4 soap_instantiate_tns__bugListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__bugListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tns__bugListResponse, n);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new tns__bugListResponse;
		if (size)
			*size = sizeof(tns__bugListResponse);
	}
	else
	{	cp->ptr = (void*)new tns__bugListResponse[n];
		if (size)
			*size = n * sizeof(tns__bugListResponse);
	}
	return (tns__bugListResponse*)cp->ptr;
}

void tns__SiteStatsDataPoint::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_tns__SiteStatsDataPoint))
		this->soap_mark(soap);
}

void tns__SiteStatsDataPoint::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((tns__SiteStatsDataPoint*)this)->date, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((tns__SiteStatsDataPoint*)this)->date);
	soap_embedded(soap, &((tns__SiteStatsDataPoint*)this)->users, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((tns__SiteStatsDataPoint*)this)->users);
	soap_embedded(soap, &((tns__SiteStatsDataPoint*)this)->pageviews, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((tns__SiteStatsDataPoint*)this)->pageviews);
	soap_embedded(soap, &((tns__SiteStatsDataPoint*)this)->sessions, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((tns__SiteStatsDataPoint*)this)->sessions);
}

void tns__SiteStatsDataPoint::soap_default(struct soap *soap)
{
	soap_default_xsd__string(soap, &((tns__SiteStatsDataPoint*)this)->date);
	soap_default_xsd__string(soap, &((tns__SiteStatsDataPoint*)this)->users);
	soap_default_xsd__string(soap, &((tns__SiteStatsDataPoint*)this)->pageviews);
	soap_default_xsd__string(soap, &((tns__SiteStatsDataPoint*)this)->sessions);
}

int tns__SiteStatsDataPoint::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_tns__SiteStatsDataPoint);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int tns__SiteStatsDataPoint::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__SiteStatsDataPoint(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__SiteStatsDataPoint(struct soap *soap, const char *tag, int id, const tns__SiteStatsDataPoint *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__SiteStatsDataPoint), "tns:SiteStatsDataPoint");
	soap_out_xsd__string(soap, "date", -1, &(((tns__SiteStatsDataPoint*)a)->date), "xsd:string");
	soap_out_xsd__string(soap, "users", -1, &(((tns__SiteStatsDataPoint*)a)->users), "xsd:string");
	soap_out_xsd__string(soap, "pageviews", -1, &(((tns__SiteStatsDataPoint*)a)->pageviews), "xsd:string");
	soap_out_xsd__string(soap, "sessions", -1, &(((tns__SiteStatsDataPoint*)a)->sessions), "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *tns__SiteStatsDataPoint::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__SiteStatsDataPoint(soap, this, tag, type);
}

SOAP_FMAC3 tns__SiteStatsDataPoint * SOAP_FMAC4 soap_get_tns__SiteStatsDataPoint(struct soap *soap, tns__SiteStatsDataPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__SiteStatsDataPoint(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *tns__SiteStatsDataPoint::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__SiteStatsDataPoint(soap, tag, this, type);
}

SOAP_FMAC3 tns__SiteStatsDataPoint * SOAP_FMAC4 soap_in_tns__SiteStatsDataPoint(struct soap *soap, const char *tag, tns__SiteStatsDataPoint *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (tns__SiteStatsDataPoint *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__SiteStatsDataPoint, sizeof(tns__SiteStatsDataPoint), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_tns__SiteStatsDataPoint)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (tns__SiteStatsDataPoint *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_date1 = 1, soap_flag_users1 = 1, soap_flag_pageviews1 = 1, soap_flag_sessions1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_date1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "date", &(((tns__SiteStatsDataPoint*)a)->date), "xsd:string"))
				{	soap_flag_date1 = 0;
					continue;
				}

			if (soap_flag_users1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "users", &(((tns__SiteStatsDataPoint*)a)->users), "xsd:string"))
				{	soap_flag_users1 = 0;
					continue;
				}

			if (soap_flag_pageviews1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "pageviews", &(((tns__SiteStatsDataPoint*)a)->pageviews), "xsd:string"))
				{	soap_flag_pageviews1 = 0;
					continue;
				}

			if (soap_flag_sessions1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "sessions", &(((tns__SiteStatsDataPoint*)a)->sessions), "xsd:string"))
				{	soap_flag_sessions1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (tns__SiteStatsDataPoint *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__SiteStatsDataPoint, sizeof(tns__SiteStatsDataPoint), soap->type, soap->arrayType), SOAP_TYPE_tns__SiteStatsDataPoint, sizeof(tns__SiteStatsDataPoint));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 tns__SiteStatsDataPoint * SOAP_FMAC4 soap_new_tns__SiteStatsDataPoint(struct soap *soap, int n)
{	return soap_instantiate_tns__SiteStatsDataPoint(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_delete_tns__SiteStatsDataPoint(struct soap *soap, tns__SiteStatsDataPoint *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 tns__SiteStatsDataPoint * SOAP_FMAC4 soap_instantiate_tns__SiteStatsDataPoint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__SiteStatsDataPoint(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tns__SiteStatsDataPoint, n);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new tns__SiteStatsDataPoint;
		if (size)
			*size = sizeof(tns__SiteStatsDataPoint);
	}
	else
	{	cp->ptr = (void*)new tns__SiteStatsDataPoint[n];
		if (size)
			*size = n * sizeof(tns__SiteStatsDataPoint);
	}
	return (tns__SiteStatsDataPoint*)cp->ptr;
}

void tns__loginResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_tns__loginResponse))
		this->soap_mark(soap);
}

void tns__loginResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((tns__loginResponse*)this)->_loginResponse, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((tns__loginResponse*)this)->_loginResponse);
}

void tns__loginResponse::soap_default(struct soap *soap)
{
	soap_default_xsd__string(soap, &((tns__loginResponse*)this)->_loginResponse);
}

int tns__loginResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_tns__loginResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int tns__loginResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__loginResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__loginResponse(struct soap *soap, const char *tag, int id, const tns__loginResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__loginResponse), "tns:loginResponse");
	soap_out_xsd__string(soap, "loginResponse", -1, &(((tns__loginResponse*)a)->_loginResponse), "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *tns__loginResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__loginResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__loginResponse * SOAP_FMAC4 soap_get_tns__loginResponse(struct soap *soap, tns__loginResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__loginResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *tns__loginResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__loginResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__loginResponse * SOAP_FMAC4 soap_in_tns__loginResponse(struct soap *soap, const char *tag, tns__loginResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (tns__loginResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__loginResponse, sizeof(tns__loginResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_tns__loginResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (tns__loginResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag__loginResponse1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag__loginResponse1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &(((tns__loginResponse*)a)->_loginResponse), "xsd:string"))
				{	soap_flag__loginResponse1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (tns__loginResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__loginResponse, sizeof(tns__loginResponse), soap->type, soap->arrayType), SOAP_TYPE_tns__loginResponse, sizeof(tns__loginResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 tns__loginResponse * SOAP_FMAC4 soap_new_tns__loginResponse(struct soap *soap, int n)
{	return soap_instantiate_tns__loginResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_delete_tns__loginResponse(struct soap *soap, tns__loginResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 tns__loginResponse * SOAP_FMAC4 soap_instantiate_tns__loginResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__loginResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tns__loginResponse, n);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new tns__loginResponse;
		if (size)
			*size = sizeof(tns__loginResponse);
	}
	else
	{	cp->ptr = (void*)new tns__loginResponse[n];
		if (size)
			*size = n * sizeof(tns__loginResponse);
	}
	return (tns__loginResponse*)cp->ptr;
}

void tns__groupResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_tns__groupResponse))
		this->soap_mark(soap);
}

void tns__groupResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((tns__groupResponse*)this)->_groupResponse, SOAP_TYPE_PointerToArrayOfGroupObject);
	soap_mark_PointerToArrayOfGroupObject(soap, &((tns__groupResponse*)this)->_groupResponse);
}

void tns__groupResponse::soap_default(struct soap *soap)
{
	soap_default_PointerToArrayOfGroupObject(soap, &((tns__groupResponse*)this)->_groupResponse);
}

int tns__groupResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_tns__groupResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int tns__groupResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__groupResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__groupResponse(struct soap *soap, const char *tag, int id, const tns__groupResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__groupResponse), "tns:groupResponse");
	soap_out_PointerToArrayOfGroupObject(soap, "groupResponse", -1, &(((tns__groupResponse*)a)->_groupResponse), "tns:GroupObject");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *tns__groupResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__groupResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__groupResponse * SOAP_FMAC4 soap_get_tns__groupResponse(struct soap *soap, tns__groupResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__groupResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *tns__groupResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__groupResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__groupResponse * SOAP_FMAC4 soap_in_tns__groupResponse(struct soap *soap, const char *tag, tns__groupResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (tns__groupResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__groupResponse, sizeof(tns__groupResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_tns__groupResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (tns__groupResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag__groupResponse1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag__groupResponse1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfGroupObject(soap, NULL, &(((tns__groupResponse*)a)->_groupResponse), "tns:GroupObject"))
				{	soap_flag__groupResponse1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (tns__groupResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__groupResponse, sizeof(tns__groupResponse), soap->type, soap->arrayType), SOAP_TYPE_tns__groupResponse, sizeof(tns__groupResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 tns__groupResponse * SOAP_FMAC4 soap_new_tns__groupResponse(struct soap *soap, int n)
{	return soap_instantiate_tns__groupResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_delete_tns__groupResponse(struct soap *soap, tns__groupResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 tns__groupResponse * SOAP_FMAC4 soap_instantiate_tns__groupResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__groupResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tns__groupResponse, n);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new tns__groupResponse;
		if (size)
			*size = sizeof(tns__groupResponse);
	}
	else
	{	cp->ptr = (void*)new tns__groupResponse[n];
		if (size)
			*size = n * sizeof(tns__groupResponse);
	}
	return (tns__groupResponse*)cp->ptr;
}

void tns__getNumberOfActiveUsersResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_tns__getNumberOfActiveUsersResponse))
		this->soap_mark(soap);
}

void tns__getNumberOfActiveUsersResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((tns__getNumberOfActiveUsersResponse*)this)->_activeUsers, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((tns__getNumberOfActiveUsersResponse*)this)->_activeUsers);
}

void tns__getNumberOfActiveUsersResponse::soap_default(struct soap *soap)
{
	soap_default_xsd__string(soap, &((tns__getNumberOfActiveUsersResponse*)this)->_activeUsers);
}

int tns__getNumberOfActiveUsersResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_tns__getNumberOfActiveUsersResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int tns__getNumberOfActiveUsersResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__getNumberOfActiveUsersResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__getNumberOfActiveUsersResponse(struct soap *soap, const char *tag, int id, const tns__getNumberOfActiveUsersResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__getNumberOfActiveUsersResponse), "tns:getNumberOfActiveUsersResponse");
	soap_out_xsd__string(soap, "activeUsers", -1, &(((tns__getNumberOfActiveUsersResponse*)a)->_activeUsers), "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *tns__getNumberOfActiveUsersResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__getNumberOfActiveUsersResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__getNumberOfActiveUsersResponse * SOAP_FMAC4 soap_get_tns__getNumberOfActiveUsersResponse(struct soap *soap, tns__getNumberOfActiveUsersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__getNumberOfActiveUsersResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *tns__getNumberOfActiveUsersResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__getNumberOfActiveUsersResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__getNumberOfActiveUsersResponse * SOAP_FMAC4 soap_in_tns__getNumberOfActiveUsersResponse(struct soap *soap, const char *tag, tns__getNumberOfActiveUsersResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (tns__getNumberOfActiveUsersResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__getNumberOfActiveUsersResponse, sizeof(tns__getNumberOfActiveUsersResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_tns__getNumberOfActiveUsersResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (tns__getNumberOfActiveUsersResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag__activeUsers1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag__activeUsers1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &(((tns__getNumberOfActiveUsersResponse*)a)->_activeUsers), "xsd:string"))
				{	soap_flag__activeUsers1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (tns__getNumberOfActiveUsersResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__getNumberOfActiveUsersResponse, sizeof(tns__getNumberOfActiveUsersResponse), soap->type, soap->arrayType), SOAP_TYPE_tns__getNumberOfActiveUsersResponse, sizeof(tns__getNumberOfActiveUsersResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 tns__getNumberOfActiveUsersResponse * SOAP_FMAC4 soap_new_tns__getNumberOfActiveUsersResponse(struct soap *soap, int n)
{	return soap_instantiate_tns__getNumberOfActiveUsersResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_delete_tns__getNumberOfActiveUsersResponse(struct soap *soap, tns__getNumberOfActiveUsersResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 tns__getNumberOfActiveUsersResponse * SOAP_FMAC4 soap_instantiate_tns__getNumberOfActiveUsersResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__getNumberOfActiveUsersResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tns__getNumberOfActiveUsersResponse, n);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new tns__getNumberOfActiveUsersResponse;
		if (size)
			*size = sizeof(tns__getNumberOfActiveUsersResponse);
	}
	else
	{	cp->ptr = (void*)new tns__getNumberOfActiveUsersResponse[n];
		if (size)
			*size = n * sizeof(tns__getNumberOfActiveUsersResponse);
	}
	return (tns__getNumberOfActiveUsersResponse*)cp->ptr;
}

void ArrayOfGroupObject::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void ArrayOfGroupObject::soap_mark(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, this->__size, SOAP_TYPE_ArrayOfGroupObject))
		for (int i = 0; i < this->__size; i++)
		{	soap_embedded(soap, this->__ptr + i, SOAP_TYPE_tns__GroupObject);
			this->__ptr[i].soap_mark(soap);
		}
}

void ArrayOfGroupObject::soap_default(struct soap *soap)
{
	this->__size = 0;
	this->__ptr = NULL;
	this->__offset = 0;
}

int ArrayOfGroupObject::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_array(soap, (void*)this, (struct soap_array*)&this->__ptr, this->__size, tag, SOAP_TYPE_ArrayOfGroupObject);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ArrayOfGroupObject::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfGroupObject(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfGroupObject(struct soap *soap, const char *tag, int id, const ArrayOfGroupObject *a, const char *type)
{
	int i;
	struct soap_plist *pp;
	int n = a->__size;
	char *t = soap_putsize(soap, "tns:GroupObject", n + a->__offset);
	i = soap_array_pointer_lookup(soap, a, (struct soap_array*)&a->__ptr, n, SOAP_TYPE_ArrayOfGroupObject, &pp);
	if (!a->__ptr)
	{	soap_element_null(soap, tag, i, t);
		return SOAP_OK;
	}
	if (id <= 0 && i)
	{	if (soap_is_embedded(soap, pp))
		{	soap_element_ref(soap, tag, 0, i);
			return SOAP_OK;
		}
		if (soap_is_single(soap, pp))
			i = 0;
	}
	else if (id > 0)
		i = id;
	soap_array_begin_out(soap, tag, i, t, soap_putoffset(soap, a->__offset));
	if (i)
		soap_set_embedded(soap, pp);
	for (i = 0; i < n; i++)
	{
		a->__ptr[i].soap_out(soap, "item", -1, type);
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfGroupObject::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfGroupObject(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfGroupObject * SOAP_FMAC4 soap_get_ArrayOfGroupObject(struct soap *soap, ArrayOfGroupObject *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfGroupObject(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfGroupObject::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfGroupObject(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfGroupObject * SOAP_FMAC4 soap_in_ArrayOfGroupObject(struct soap *soap, const char *tag, ArrayOfGroupObject *a, const char *type)
{	int i, j;
	tns__GroupObject *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if ((a = (ArrayOfGroupObject *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfGroupObject, sizeof(ArrayOfGroupObject), soap->type, soap->arrayType)))
			a->soap_default(soap);
			if (soap->body && soap_element_end_in(soap, tag))
				return NULL;
	}
	else if (!*soap->href)
	{	if (!(a = (ArrayOfGroupObject *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfGroupObject, sizeof(ArrayOfGroupObject), soap->type, soap->arrayType)))
			return NULL;
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body)
		{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		a->__offset = j;
		if (a->__size >= 0)
		{	a->__ptr = soap_new_tns__GroupObject(soap, a->__size);
			for (i = 0; i < a->__size; i++)
				(a->__ptr+i)->tns__GroupObject::soap_default(soap);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
					return NULL;
					}
				}
				if (!soap_in_tns__GroupObject(soap, NULL, a->__ptr + i, "tns:GroupObject"))
				{	if (soap->error == SOAP_NO_TAG)
					{	soap->error = SOAP_OK;
						break;
					}
					else
						return NULL;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (tns__GroupObject *)soap_push_block(soap, sizeof(tns__GroupObject));
				if (!p)
					return NULL;
				p->tns__GroupObject::soap_default(soap);
				if (!soap_in_tns__GroupObject(soap, NULL, p, "tns:GroupObject"))
				{	if (soap->error == SOAP_NO_TAG)
					{	soap->error = SOAP_OK;
						break;
					}
					else
						return NULL;
				}
			}
			soap_pop_block(soap);
			if (soap->blist->size)
				a->__ptr = soap_new_tns__GroupObject(soap, soap->blist->size/sizeof(tns__GroupObject));
			else
				a->__ptr = NULL;
			soap_store_block(soap, (char*)a->__ptr);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ArrayOfGroupObject *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfGroupObject, sizeof(ArrayOfGroupObject), soap->type, soap->arrayType), SOAP_TYPE_ArrayOfGroupObject, sizeof(ArrayOfGroupObject));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ArrayOfGroupObject * SOAP_FMAC4 soap_new_ArrayOfGroupObject(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfGroupObject(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_delete_ArrayOfGroupObject(struct soap *soap, ArrayOfGroupObject *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfGroupObject * SOAP_FMAC4 soap_instantiate_ArrayOfGroupObject(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfGroupObject(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfGroupObject, n);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfGroupObject;
		if (size)
			*size = sizeof(ArrayOfGroupObject);
	}
	else
	{	cp->ptr = (void*)new ArrayOfGroupObject[n];
		if (size)
			*size = n * sizeof(ArrayOfGroupObject);
	}
	return (ArrayOfGroupObject*)cp->ptr;
}

void ArrayOfBug::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void ArrayOfBug::soap_mark(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, this->__size, SOAP_TYPE_ArrayOfBug))
		for (int i = 0; i < this->__size; i++)
		{	soap_embedded(soap, this->__ptr + i, SOAP_TYPE_tns__Bug);
			this->__ptr[i].soap_mark(soap);
		}
}

void ArrayOfBug::soap_default(struct soap *soap)
{
	this->__size = 0;
	this->__ptr = NULL;
	this->__offset = 0;
}

int ArrayOfBug::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_array(soap, (void*)this, (struct soap_array*)&this->__ptr, this->__size, tag, SOAP_TYPE_ArrayOfBug);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ArrayOfBug::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfBug(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfBug(struct soap *soap, const char *tag, int id, const ArrayOfBug *a, const char *type)
{
	int i;
	struct soap_plist *pp;
	int n = a->__size;
	char *t = soap_putsize(soap, "tns:Bug", n + a->__offset);
	i = soap_array_pointer_lookup(soap, a, (struct soap_array*)&a->__ptr, n, SOAP_TYPE_ArrayOfBug, &pp);
	if (!a->__ptr)
	{	soap_element_null(soap, tag, i, t);
		return SOAP_OK;
	}
	if (id <= 0 && i)
	{	if (soap_is_embedded(soap, pp))
		{	soap_element_ref(soap, tag, 0, i);
			return SOAP_OK;
		}
		if (soap_is_single(soap, pp))
			i = 0;
	}
	else if (id > 0)
		i = id;
	soap_array_begin_out(soap, tag, i, t, soap_putoffset(soap, a->__offset));
	if (i)
		soap_set_embedded(soap, pp);
	for (i = 0; i < n; i++)
	{
		a->__ptr[i].soap_out(soap, "item", -1, type);
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfBug::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfBug(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfBug * SOAP_FMAC4 soap_get_ArrayOfBug(struct soap *soap, ArrayOfBug *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfBug(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfBug::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfBug(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfBug * SOAP_FMAC4 soap_in_ArrayOfBug(struct soap *soap, const char *tag, ArrayOfBug *a, const char *type)
{	int i, j;
	tns__Bug *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if ((a = (ArrayOfBug *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfBug, sizeof(ArrayOfBug), soap->type, soap->arrayType)))
			a->soap_default(soap);
			if (soap->body && soap_element_end_in(soap, tag))
				return NULL;
	}
	else if (!*soap->href)
	{	if (!(a = (ArrayOfBug *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfBug, sizeof(ArrayOfBug), soap->type, soap->arrayType)))
			return NULL;
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body)
		{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		a->__offset = j;
		if (a->__size >= 0)
		{	a->__ptr = soap_new_tns__Bug(soap, a->__size);
			for (i = 0; i < a->__size; i++)
				(a->__ptr+i)->tns__Bug::soap_default(soap);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
					return NULL;
					}
				}
				if (!soap_in_tns__Bug(soap, NULL, a->__ptr + i, "tns:Bug"))
				{	if (soap->error == SOAP_NO_TAG)
					{	soap->error = SOAP_OK;
						break;
					}
					else
						return NULL;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (tns__Bug *)soap_push_block(soap, sizeof(tns__Bug));
				if (!p)
					return NULL;
				p->tns__Bug::soap_default(soap);
				if (!soap_in_tns__Bug(soap, NULL, p, "tns:Bug"))
				{	if (soap->error == SOAP_NO_TAG)
					{	soap->error = SOAP_OK;
						break;
					}
					else
						return NULL;
				}
			}
			soap_pop_block(soap);
			if (soap->blist->size)
				a->__ptr = soap_new_tns__Bug(soap, soap->blist->size/sizeof(tns__Bug));
			else
				a->__ptr = NULL;
			soap_store_block(soap, (char*)a->__ptr);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ArrayOfBug *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfBug, sizeof(ArrayOfBug), soap->type, soap->arrayType), SOAP_TYPE_ArrayOfBug, sizeof(ArrayOfBug));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ArrayOfBug * SOAP_FMAC4 soap_new_ArrayOfBug(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfBug(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_delete_ArrayOfBug(struct soap *soap, ArrayOfBug *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfBug * SOAP_FMAC4 soap_instantiate_ArrayOfBug(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfBug(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfBug, n);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfBug;
		if (size)
			*size = sizeof(ArrayOfBug);
	}
	else
	{	cp->ptr = (void*)new ArrayOfBug[n];
		if (size)
			*size = n * sizeof(ArrayOfBug);
	}
	return (ArrayOfBug*)cp->ptr;
}

void tns__GroupObject::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_tns__GroupObject))
		this->soap_mark(soap);
}

void tns__GroupObject::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((tns__GroupObject*)this)->group_USCORE_id, SOAP_TYPE_xsd__integer);
	soap_mark_xsd__integer(soap, &((tns__GroupObject*)this)->group_USCORE_id);
	soap_embedded(soap, &((tns__GroupObject*)this)->group_USCORE_name, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((tns__GroupObject*)this)->group_USCORE_name);
	soap_embedded(soap, &((tns__GroupObject*)this)->is_USCORE_public, SOAP_TYPE_xsd__integer);
	soap_mark_xsd__integer(soap, &((tns__GroupObject*)this)->is_USCORE_public);
	soap_embedded(soap, &((tns__GroupObject*)this)->status, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((tns__GroupObject*)this)->status);
	soap_embedded(soap, &((tns__GroupObject*)this)->unix_USCORE_group_USCORE_name, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((tns__GroupObject*)this)->unix_USCORE_group_USCORE_name);
}

void tns__GroupObject::soap_default(struct soap *soap)
{
	soap_default_xsd__integer(soap, &((tns__GroupObject*)this)->group_USCORE_id);
	soap_default_xsd__string(soap, &((tns__GroupObject*)this)->group_USCORE_name);
	soap_default_xsd__integer(soap, &((tns__GroupObject*)this)->is_USCORE_public);
	soap_default_xsd__string(soap, &((tns__GroupObject*)this)->status);
	soap_default_xsd__string(soap, &((tns__GroupObject*)this)->unix_USCORE_group_USCORE_name);
}

int tns__GroupObject::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_tns__GroupObject);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int tns__GroupObject::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__GroupObject(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__GroupObject(struct soap *soap, const char *tag, int id, const tns__GroupObject *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__GroupObject), "tns:GroupObject");
	soap_out_xsd__integer(soap, "group_id", -1, &(((tns__GroupObject*)a)->group_USCORE_id), "xsd:integer");
	soap_out_xsd__string(soap, "group_name", -1, &(((tns__GroupObject*)a)->group_USCORE_name), "xsd:string");
	soap_out_xsd__integer(soap, "is_public", -1, &(((tns__GroupObject*)a)->is_USCORE_public), "xsd:integer");
	soap_out_xsd__string(soap, "status", -1, &(((tns__GroupObject*)a)->status), "xsd:string");
	soap_out_xsd__string(soap, "unix_group_name", -1, &(((tns__GroupObject*)a)->unix_USCORE_group_USCORE_name), "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *tns__GroupObject::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__GroupObject(soap, this, tag, type);
}

SOAP_FMAC3 tns__GroupObject * SOAP_FMAC4 soap_get_tns__GroupObject(struct soap *soap, tns__GroupObject *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__GroupObject(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *tns__GroupObject::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__GroupObject(soap, tag, this, type);
}

SOAP_FMAC3 tns__GroupObject * SOAP_FMAC4 soap_in_tns__GroupObject(struct soap *soap, const char *tag, tns__GroupObject *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (tns__GroupObject *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__GroupObject, sizeof(tns__GroupObject), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_tns__GroupObject)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (tns__GroupObject *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_group_USCORE_id1 = 1, soap_flag_group_USCORE_name1 = 1, soap_flag_is_USCORE_public1 = 1, soap_flag_status1 = 1, soap_flag_unix_USCORE_group_USCORE_name1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_group_USCORE_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__integer(soap, "group_id", &(((tns__GroupObject*)a)->group_USCORE_id), "xsd:integer"))
				{	soap_flag_group_USCORE_id1 = 0;
					continue;
				}

			if (soap_flag_group_USCORE_name1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "group_name", &(((tns__GroupObject*)a)->group_USCORE_name), "xsd:string"))
				{	soap_flag_group_USCORE_name1 = 0;
					continue;
				}

			if (soap_flag_is_USCORE_public1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__integer(soap, "is_public", &(((tns__GroupObject*)a)->is_USCORE_public), "xsd:integer"))
				{	soap_flag_is_USCORE_public1 = 0;
					continue;
				}

			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "status", &(((tns__GroupObject*)a)->status), "xsd:string"))
				{	soap_flag_status1 = 0;
					continue;
				}

			if (soap_flag_unix_USCORE_group_USCORE_name1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "unix_group_name", &(((tns__GroupObject*)a)->unix_USCORE_group_USCORE_name), "xsd:string"))
				{	soap_flag_unix_USCORE_group_USCORE_name1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (tns__GroupObject *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__GroupObject, sizeof(tns__GroupObject), soap->type, soap->arrayType), SOAP_TYPE_tns__GroupObject, sizeof(tns__GroupObject));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 tns__GroupObject * SOAP_FMAC4 soap_new_tns__GroupObject(struct soap *soap, int n)
{	return soap_instantiate_tns__GroupObject(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_delete_tns__GroupObject(struct soap *soap, tns__GroupObject *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 tns__GroupObject * SOAP_FMAC4 soap_instantiate_tns__GroupObject(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__GroupObject(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tns__GroupObject, n);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new tns__GroupObject;
		if (size)
			*size = sizeof(tns__GroupObject);
	}
	else
	{	cp->ptr = (void*)new tns__GroupObject[n];
		if (size)
			*size = n * sizeof(tns__GroupObject);
	}
	return (tns__GroupObject*)cp->ptr;
}

void ArrayOfSiteStatsDataPoint::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void ArrayOfSiteStatsDataPoint::soap_mark(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, this->__size, SOAP_TYPE_ArrayOfSiteStatsDataPoint))
		for (int i = 0; i < this->__size; i++)
		{	soap_embedded(soap, this->__ptr + i, SOAP_TYPE_tns__SiteStatsDataPoint);
			this->__ptr[i].soap_mark(soap);
		}
}

void ArrayOfSiteStatsDataPoint::soap_default(struct soap *soap)
{
	this->__size = 0;
	this->__ptr = NULL;
	this->__offset = 0;
}

int ArrayOfSiteStatsDataPoint::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_array(soap, (void*)this, (struct soap_array*)&this->__ptr, this->__size, tag, SOAP_TYPE_ArrayOfSiteStatsDataPoint);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ArrayOfSiteStatsDataPoint::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfSiteStatsDataPoint(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfSiteStatsDataPoint(struct soap *soap, const char *tag, int id, const ArrayOfSiteStatsDataPoint *a, const char *type)
{
	int i;
	struct soap_plist *pp;
	int n = a->__size;
	char *t = soap_putsize(soap, "tns:SiteStatsDataPoint", n + a->__offset);
	i = soap_array_pointer_lookup(soap, a, (struct soap_array*)&a->__ptr, n, SOAP_TYPE_ArrayOfSiteStatsDataPoint, &pp);
	if (!a->__ptr)
	{	soap_element_null(soap, tag, i, t);
		return SOAP_OK;
	}
	if (id <= 0 && i)
	{	if (soap_is_embedded(soap, pp))
		{	soap_element_ref(soap, tag, 0, i);
			return SOAP_OK;
		}
		if (soap_is_single(soap, pp))
			i = 0;
	}
	else if (id > 0)
		i = id;
	soap_array_begin_out(soap, tag, i, t, soap_putoffset(soap, a->__offset));
	if (i)
		soap_set_embedded(soap, pp);
	for (i = 0; i < n; i++)
	{
		a->__ptr[i].soap_out(soap, "item", -1, type);
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfSiteStatsDataPoint::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfSiteStatsDataPoint(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfSiteStatsDataPoint * SOAP_FMAC4 soap_get_ArrayOfSiteStatsDataPoint(struct soap *soap, ArrayOfSiteStatsDataPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfSiteStatsDataPoint(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfSiteStatsDataPoint::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfSiteStatsDataPoint(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfSiteStatsDataPoint * SOAP_FMAC4 soap_in_ArrayOfSiteStatsDataPoint(struct soap *soap, const char *tag, ArrayOfSiteStatsDataPoint *a, const char *type)
{	int i, j;
	tns__SiteStatsDataPoint *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if ((a = (ArrayOfSiteStatsDataPoint *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfSiteStatsDataPoint, sizeof(ArrayOfSiteStatsDataPoint), soap->type, soap->arrayType)))
			a->soap_default(soap);
			if (soap->body && soap_element_end_in(soap, tag))
				return NULL;
	}
	else if (!*soap->href)
	{	if (!(a = (ArrayOfSiteStatsDataPoint *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfSiteStatsDataPoint, sizeof(ArrayOfSiteStatsDataPoint), soap->type, soap->arrayType)))
			return NULL;
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body)
		{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		a->__offset = j;
		if (a->__size >= 0)
		{	a->__ptr = soap_new_tns__SiteStatsDataPoint(soap, a->__size);
			for (i = 0; i < a->__size; i++)
				(a->__ptr+i)->tns__SiteStatsDataPoint::soap_default(soap);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
					return NULL;
					}
				}
				if (!soap_in_tns__SiteStatsDataPoint(soap, NULL, a->__ptr + i, "tns:SiteStatsDataPoint"))
				{	if (soap->error == SOAP_NO_TAG)
					{	soap->error = SOAP_OK;
						break;
					}
					else
						return NULL;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (tns__SiteStatsDataPoint *)soap_push_block(soap, sizeof(tns__SiteStatsDataPoint));
				if (!p)
					return NULL;
				p->tns__SiteStatsDataPoint::soap_default(soap);
				if (!soap_in_tns__SiteStatsDataPoint(soap, NULL, p, "tns:SiteStatsDataPoint"))
				{	if (soap->error == SOAP_NO_TAG)
					{	soap->error = SOAP_OK;
						break;
					}
					else
						return NULL;
				}
			}
			soap_pop_block(soap);
			if (soap->blist->size)
				a->__ptr = soap_new_tns__SiteStatsDataPoint(soap, soap->blist->size/sizeof(tns__SiteStatsDataPoint));
			else
				a->__ptr = NULL;
			soap_store_block(soap, (char*)a->__ptr);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ArrayOfSiteStatsDataPoint *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfSiteStatsDataPoint, sizeof(ArrayOfSiteStatsDataPoint), soap->type, soap->arrayType), SOAP_TYPE_ArrayOfSiteStatsDataPoint, sizeof(ArrayOfSiteStatsDataPoint));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ArrayOfSiteStatsDataPoint * SOAP_FMAC4 soap_new_ArrayOfSiteStatsDataPoint(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfSiteStatsDataPoint(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_delete_ArrayOfSiteStatsDataPoint(struct soap *soap, ArrayOfSiteStatsDataPoint *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfSiteStatsDataPoint * SOAP_FMAC4 soap_instantiate_ArrayOfSiteStatsDataPoint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfSiteStatsDataPoint(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfSiteStatsDataPoint, n);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfSiteStatsDataPoint;
		if (size)
			*size = sizeof(ArrayOfSiteStatsDataPoint);
	}
	else
	{	cp->ptr = (void*)new ArrayOfSiteStatsDataPoint[n];
		if (size)
			*size = n * sizeof(ArrayOfSiteStatsDataPoint);
	}
	return (ArrayOfSiteStatsDataPoint*)cp->ptr;
}

void tns__getSiteStatsResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_tns__getSiteStatsResponse))
		this->soap_mark(soap);
}

void tns__getSiteStatsResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((tns__getSiteStatsResponse*)this)->_siteStats, SOAP_TYPE_PointerToArrayOfSiteStatsDataPoint);
	soap_mark_PointerToArrayOfSiteStatsDataPoint(soap, &((tns__getSiteStatsResponse*)this)->_siteStats);
}

void tns__getSiteStatsResponse::soap_default(struct soap *soap)
{
	soap_default_PointerToArrayOfSiteStatsDataPoint(soap, &((tns__getSiteStatsResponse*)this)->_siteStats);
}

int tns__getSiteStatsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_tns__getSiteStatsResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int tns__getSiteStatsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__getSiteStatsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__getSiteStatsResponse(struct soap *soap, const char *tag, int id, const tns__getSiteStatsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__getSiteStatsResponse), "tns:getSiteStatsResponse");
	soap_out_PointerToArrayOfSiteStatsDataPoint(soap, "siteStats", -1, &(((tns__getSiteStatsResponse*)a)->_siteStats), "tns:SiteStatsDataPoint");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *tns__getSiteStatsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__getSiteStatsResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__getSiteStatsResponse * SOAP_FMAC4 soap_get_tns__getSiteStatsResponse(struct soap *soap, tns__getSiteStatsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__getSiteStatsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *tns__getSiteStatsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__getSiteStatsResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__getSiteStatsResponse * SOAP_FMAC4 soap_in_tns__getSiteStatsResponse(struct soap *soap, const char *tag, tns__getSiteStatsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (tns__getSiteStatsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__getSiteStatsResponse, sizeof(tns__getSiteStatsResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_tns__getSiteStatsResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (tns__getSiteStatsResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag__siteStats1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag__siteStats1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfSiteStatsDataPoint(soap, NULL, &(((tns__getSiteStatsResponse*)a)->_siteStats), "tns:SiteStatsDataPoint"))
				{	soap_flag__siteStats1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (tns__getSiteStatsResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__getSiteStatsResponse, sizeof(tns__getSiteStatsResponse), soap->type, soap->arrayType), SOAP_TYPE_tns__getSiteStatsResponse, sizeof(tns__getSiteStatsResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 tns__getSiteStatsResponse * SOAP_FMAC4 soap_new_tns__getSiteStatsResponse(struct soap *soap, int n)
{	return soap_instantiate_tns__getSiteStatsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_delete_tns__getSiteStatsResponse(struct soap *soap, tns__getSiteStatsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 tns__getSiteStatsResponse * SOAP_FMAC4 soap_instantiate_tns__getSiteStatsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__getSiteStatsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tns__getSiteStatsResponse, n);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new tns__getSiteStatsResponse;
		if (size)
			*size = sizeof(tns__getSiteStatsResponse);
	}
	else
	{	cp->ptr = (void*)new tns__getSiteStatsResponse[n];
		if (size)
			*size = n * sizeof(tns__getSiteStatsResponse);
	}
	return (tns__getSiteStatsResponse*)cp->ptr;
}

void tns__getPublicProjectNamesResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_tns__getPublicProjectNamesResponse))
		this->soap_mark(soap);
}

void tns__getPublicProjectNamesResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((tns__getPublicProjectNamesResponse*)this)->_projectNames, SOAP_TYPE_PointerTotns__ArrayOfstring);
	soap_mark_PointerTotns__ArrayOfstring(soap, &((tns__getPublicProjectNamesResponse*)this)->_projectNames);
}

void tns__getPublicProjectNamesResponse::soap_default(struct soap *soap)
{
	soap_default_PointerTotns__ArrayOfstring(soap, &((tns__getPublicProjectNamesResponse*)this)->_projectNames);
}

int tns__getPublicProjectNamesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_tns__getPublicProjectNamesResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int tns__getPublicProjectNamesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__getPublicProjectNamesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__getPublicProjectNamesResponse(struct soap *soap, const char *tag, int id, const tns__getPublicProjectNamesResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__getPublicProjectNamesResponse), "tns:getPublicProjectNamesResponse");
	soap_out_PointerTotns__ArrayOfstring(soap, "projectNames", -1, &(((tns__getPublicProjectNamesResponse*)a)->_projectNames), "tns:ArrayOfstring");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *tns__getPublicProjectNamesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__getPublicProjectNamesResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__getPublicProjectNamesResponse * SOAP_FMAC4 soap_get_tns__getPublicProjectNamesResponse(struct soap *soap, tns__getPublicProjectNamesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__getPublicProjectNamesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *tns__getPublicProjectNamesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__getPublicProjectNamesResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__getPublicProjectNamesResponse * SOAP_FMAC4 soap_in_tns__getPublicProjectNamesResponse(struct soap *soap, const char *tag, tns__getPublicProjectNamesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (tns__getPublicProjectNamesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__getPublicProjectNamesResponse, sizeof(tns__getPublicProjectNamesResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_tns__getPublicProjectNamesResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (tns__getPublicProjectNamesResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag__projectNames1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag__projectNames1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__ArrayOfstring(soap, NULL, &(((tns__getPublicProjectNamesResponse*)a)->_projectNames), "tns:ArrayOfstring"))
				{	soap_flag__projectNames1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (tns__getPublicProjectNamesResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__getPublicProjectNamesResponse, sizeof(tns__getPublicProjectNamesResponse), soap->type, soap->arrayType), SOAP_TYPE_tns__getPublicProjectNamesResponse, sizeof(tns__getPublicProjectNamesResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 tns__getPublicProjectNamesResponse * SOAP_FMAC4 soap_new_tns__getPublicProjectNamesResponse(struct soap *soap, int n)
{	return soap_instantiate_tns__getPublicProjectNamesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_delete_tns__getPublicProjectNamesResponse(struct soap *soap, tns__getPublicProjectNamesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 tns__getPublicProjectNamesResponse * SOAP_FMAC4 soap_instantiate_tns__getPublicProjectNamesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__getPublicProjectNamesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tns__getPublicProjectNamesResponse, n);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new tns__getPublicProjectNamesResponse;
		if (size)
			*size = sizeof(tns__getPublicProjectNamesResponse);
	}
	else
	{	cp->ptr = (void*)new tns__getPublicProjectNamesResponse[n];
		if (size)
			*size = n * sizeof(tns__getPublicProjectNamesResponse);
	}
	return (tns__getPublicProjectNamesResponse*)cp->ptr;
}

void tns__logoutResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_tns__logoutResponse))
		this->soap_mark(soap);
}

void tns__logoutResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((tns__logoutResponse*)this)->_logoutResponse, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((tns__logoutResponse*)this)->_logoutResponse);
}

void tns__logoutResponse::soap_default(struct soap *soap)
{
	soap_default_xsd__string(soap, &((tns__logoutResponse*)this)->_logoutResponse);
}

int tns__logoutResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_tns__logoutResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int tns__logoutResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__logoutResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__logoutResponse(struct soap *soap, const char *tag, int id, const tns__logoutResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__logoutResponse), "tns:logoutResponse");
	soap_out_xsd__string(soap, "logoutResponse", -1, &(((tns__logoutResponse*)a)->_logoutResponse), "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *tns__logoutResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__logoutResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__logoutResponse * SOAP_FMAC4 soap_get_tns__logoutResponse(struct soap *soap, tns__logoutResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__logoutResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *tns__logoutResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__logoutResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__logoutResponse * SOAP_FMAC4 soap_in_tns__logoutResponse(struct soap *soap, const char *tag, tns__logoutResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (tns__logoutResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__logoutResponse, sizeof(tns__logoutResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_tns__logoutResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (tns__logoutResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag__logoutResponse1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag__logoutResponse1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &(((tns__logoutResponse*)a)->_logoutResponse), "xsd:string"))
				{	soap_flag__logoutResponse1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (tns__logoutResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__logoutResponse, sizeof(tns__logoutResponse), soap->type, soap->arrayType), SOAP_TYPE_tns__logoutResponse, sizeof(tns__logoutResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 tns__logoutResponse * SOAP_FMAC4 soap_new_tns__logoutResponse(struct soap *soap, int n)
{	return soap_instantiate_tns__logoutResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_delete_tns__logoutResponse(struct soap *soap, tns__logoutResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 tns__logoutResponse * SOAP_FMAC4 soap_instantiate_tns__logoutResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__logoutResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tns__logoutResponse, n);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new tns__logoutResponse;
		if (size)
			*size = sizeof(tns__logoutResponse);
	}
	else
	{	cp->ptr = (void*)new tns__logoutResponse[n];
		if (size)
			*size = n * sizeof(tns__logoutResponse);
	}
	return (tns__logoutResponse*)cp->ptr;
}

void tns__Bug::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_tns__Bug))
		this->soap_mark(soap);
}

void tns__Bug::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((tns__Bug*)this)->id, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((tns__Bug*)this)->id);
	soap_embedded(soap, &((tns__Bug*)this)->summary, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((tns__Bug*)this)->summary);
}

void tns__Bug::soap_default(struct soap *soap)
{
	soap_default_xsd__string(soap, &((tns__Bug*)this)->id);
	soap_default_xsd__string(soap, &((tns__Bug*)this)->summary);
}

int tns__Bug::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_tns__Bug);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int tns__Bug::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__Bug(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__Bug(struct soap *soap, const char *tag, int id, const tns__Bug *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__Bug), "tns:Bug");
	soap_out_xsd__string(soap, "id", -1, &(((tns__Bug*)a)->id), "xsd:string");
	soap_out_xsd__string(soap, "summary", -1, &(((tns__Bug*)a)->summary), "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *tns__Bug::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__Bug(soap, this, tag, type);
}

SOAP_FMAC3 tns__Bug * SOAP_FMAC4 soap_get_tns__Bug(struct soap *soap, tns__Bug *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__Bug(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *tns__Bug::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__Bug(soap, tag, this, type);
}

SOAP_FMAC3 tns__Bug * SOAP_FMAC4 soap_in_tns__Bug(struct soap *soap, const char *tag, tns__Bug *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (tns__Bug *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__Bug, sizeof(tns__Bug), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_tns__Bug)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (tns__Bug *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_id1 = 1, soap_flag_summary1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "id", &(((tns__Bug*)a)->id), "xsd:string"))
				{	soap_flag_id1 = 0;
					continue;
				}

			if (soap_flag_summary1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "summary", &(((tns__Bug*)a)->summary), "xsd:string"))
				{	soap_flag_summary1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (tns__Bug *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__Bug, sizeof(tns__Bug), soap->type, soap->arrayType), SOAP_TYPE_tns__Bug, sizeof(tns__Bug));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 tns__Bug * SOAP_FMAC4 soap_new_tns__Bug(struct soap *soap, int n)
{	return soap_instantiate_tns__Bug(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_delete_tns__Bug(struct soap *soap, tns__Bug *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 tns__Bug * SOAP_FMAC4 soap_instantiate_tns__Bug(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__Bug(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tns__Bug, n);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new tns__Bug;
		if (size)
			*size = sizeof(tns__Bug);
	}
	else
	{	cp->ptr = (void*)new tns__Bug[n];
		if (size)
			*size = n * sizeof(tns__Bug);
	}
	return (tns__Bug*)cp->ptr;
}

void tns__bugFetchResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_tns__bugFetchResponse))
		this->soap_mark(soap);
}

void tns__bugFetchResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((tns__bugFetchResponse*)this)->_bugFetchResponse, SOAP_TYPE_PointerTotns__Bug);
	soap_mark_PointerTotns__Bug(soap, &((tns__bugFetchResponse*)this)->_bugFetchResponse);
}

void tns__bugFetchResponse::soap_default(struct soap *soap)
{
	soap_default_PointerTotns__Bug(soap, &((tns__bugFetchResponse*)this)->_bugFetchResponse);
}

int tns__bugFetchResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_tns__bugFetchResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int tns__bugFetchResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__bugFetchResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__bugFetchResponse(struct soap *soap, const char *tag, int id, const tns__bugFetchResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__bugFetchResponse), "tns:bugFetchResponse");
	soap_out_PointerTotns__Bug(soap, "bugFetchResponse", -1, &(((tns__bugFetchResponse*)a)->_bugFetchResponse), "tns:Bug");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *tns__bugFetchResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__bugFetchResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__bugFetchResponse * SOAP_FMAC4 soap_get_tns__bugFetchResponse(struct soap *soap, tns__bugFetchResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__bugFetchResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *tns__bugFetchResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__bugFetchResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__bugFetchResponse * SOAP_FMAC4 soap_in_tns__bugFetchResponse(struct soap *soap, const char *tag, tns__bugFetchResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (tns__bugFetchResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__bugFetchResponse, sizeof(tns__bugFetchResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_tns__bugFetchResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (tns__bugFetchResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag__bugFetchResponse1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag__bugFetchResponse1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__Bug(soap, NULL, &(((tns__bugFetchResponse*)a)->_bugFetchResponse), "tns:Bug"))
				{	soap_flag__bugFetchResponse1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (tns__bugFetchResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__bugFetchResponse, sizeof(tns__bugFetchResponse), soap->type, soap->arrayType), SOAP_TYPE_tns__bugFetchResponse, sizeof(tns__bugFetchResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 tns__bugFetchResponse * SOAP_FMAC4 soap_new_tns__bugFetchResponse(struct soap *soap, int n)
{	return soap_instantiate_tns__bugFetchResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_delete_tns__bugFetchResponse(struct soap *soap, tns__bugFetchResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 tns__bugFetchResponse * SOAP_FMAC4 soap_instantiate_tns__bugFetchResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__bugFetchResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tns__bugFetchResponse, n);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new tns__bugFetchResponse;
		if (size)
			*size = sizeof(tns__bugFetchResponse);
	}
	else
	{	cp->ptr = (void*)new tns__bugFetchResponse[n];
		if (size)
			*size = n * sizeof(tns__bugFetchResponse);
	}
	return (tns__bugFetchResponse*)cp->ptr;
}

void tns__ArrayOfstring::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_tns__ArrayOfstring))
		this->soap_mark(soap);
}

void tns__ArrayOfstring::soap_mark(struct soap *soap) const
{
}

void tns__ArrayOfstring::soap_default(struct soap *soap)
{
}

int tns__ArrayOfstring::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_tns__ArrayOfstring);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int tns__ArrayOfstring::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__ArrayOfstring(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__ArrayOfstring(struct soap *soap, const char *tag, int id, const tns__ArrayOfstring *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__ArrayOfstring), "tns:ArrayOfstring");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *tns__ArrayOfstring::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__ArrayOfstring(soap, this, tag, type);
}

SOAP_FMAC3 tns__ArrayOfstring * SOAP_FMAC4 soap_get_tns__ArrayOfstring(struct soap *soap, tns__ArrayOfstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__ArrayOfstring(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *tns__ArrayOfstring::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__ArrayOfstring(soap, tag, this, type);
}

SOAP_FMAC3 tns__ArrayOfstring * SOAP_FMAC4 soap_in_tns__ArrayOfstring(struct soap *soap, const char *tag, tns__ArrayOfstring *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (tns__ArrayOfstring *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__ArrayOfstring, sizeof(tns__ArrayOfstring), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_tns__ArrayOfstring)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (tns__ArrayOfstring *)a->soap_in(soap, tag, type);
			}
		};
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (tns__ArrayOfstring *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__ArrayOfstring, sizeof(tns__ArrayOfstring), soap->type, soap->arrayType), SOAP_TYPE_tns__ArrayOfstring, sizeof(tns__ArrayOfstring));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 tns__ArrayOfstring * SOAP_FMAC4 soap_new_tns__ArrayOfstring(struct soap *soap, int n)
{	return soap_instantiate_tns__ArrayOfstring(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_delete_tns__ArrayOfstring(struct soap *soap, tns__ArrayOfstring *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 tns__ArrayOfstring * SOAP_FMAC4 soap_instantiate_tns__ArrayOfstring(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__ArrayOfstring(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tns__ArrayOfstring, n);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new tns__ArrayOfstring;
		if (size)
			*size = sizeof(tns__ArrayOfstring);
	}
	else
	{	cp->ptr = (void*)new tns__ArrayOfstring[n];
		if (size)
			*size = n * sizeof(tns__ArrayOfstring);
	}
	return (tns__ArrayOfstring*)cp->ptr;
}

void tns__userResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_tns__userResponse))
		this->soap_mark(soap);
}

void tns__userResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((tns__userResponse*)this)->_userResponse, SOAP_TYPE_PointerTotns__ArrayOfstring);
	soap_mark_PointerTotns__ArrayOfstring(soap, &((tns__userResponse*)this)->_userResponse);
}

void tns__userResponse::soap_default(struct soap *soap)
{
	soap_default_PointerTotns__ArrayOfstring(soap, &((tns__userResponse*)this)->_userResponse);
}

int tns__userResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_tns__userResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int tns__userResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__userResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__userResponse(struct soap *soap, const char *tag, int id, const tns__userResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__userResponse), "tns:userResponse");
	soap_out_PointerTotns__ArrayOfstring(soap, "userResponse", -1, &(((tns__userResponse*)a)->_userResponse), "tns:ArrayOfstring");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *tns__userResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__userResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__userResponse * SOAP_FMAC4 soap_get_tns__userResponse(struct soap *soap, tns__userResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__userResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *tns__userResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__userResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__userResponse * SOAP_FMAC4 soap_in_tns__userResponse(struct soap *soap, const char *tag, tns__userResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (tns__userResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__userResponse, sizeof(tns__userResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_tns__userResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (tns__userResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag__userResponse1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag__userResponse1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__ArrayOfstring(soap, NULL, &(((tns__userResponse*)a)->_userResponse), "tns:ArrayOfstring"))
				{	soap_flag__userResponse1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (tns__userResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__userResponse, sizeof(tns__userResponse), soap->type, soap->arrayType), SOAP_TYPE_tns__userResponse, sizeof(tns__userResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 tns__userResponse * SOAP_FMAC4 soap_new_tns__userResponse(struct soap *soap, int n)
{	return soap_instantiate_tns__userResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_delete_tns__userResponse(struct soap *soap, tns__userResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 tns__userResponse * SOAP_FMAC4 soap_instantiate_tns__userResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__userResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tns__userResponse, n);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new tns__userResponse;
		if (size)
			*size = sizeof(tns__userResponse);
	}
	else
	{	cp->ptr = (void*)new tns__userResponse[n];
		if (size)
			*size = n * sizeof(tns__userResponse);
	}
	return (tns__userResponse*)cp->ptr;
}

void tns__bugUpdateResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_tns__bugUpdateResponse))
		this->soap_mark(soap);
}

void tns__bugUpdateResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((tns__bugUpdateResponse*)this)->_bugUpdateResponse, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((tns__bugUpdateResponse*)this)->_bugUpdateResponse);
}

void tns__bugUpdateResponse::soap_default(struct soap *soap)
{
	soap_default_xsd__string(soap, &((tns__bugUpdateResponse*)this)->_bugUpdateResponse);
}

int tns__bugUpdateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_tns__bugUpdateResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int tns__bugUpdateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__bugUpdateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__bugUpdateResponse(struct soap *soap, const char *tag, int id, const tns__bugUpdateResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__bugUpdateResponse), "tns:bugUpdateResponse");
	soap_out_xsd__string(soap, "bugUpdateResponse", -1, &(((tns__bugUpdateResponse*)a)->_bugUpdateResponse), "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *tns__bugUpdateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__bugUpdateResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__bugUpdateResponse * SOAP_FMAC4 soap_get_tns__bugUpdateResponse(struct soap *soap, tns__bugUpdateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__bugUpdateResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *tns__bugUpdateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__bugUpdateResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__bugUpdateResponse * SOAP_FMAC4 soap_in_tns__bugUpdateResponse(struct soap *soap, const char *tag, tns__bugUpdateResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (tns__bugUpdateResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__bugUpdateResponse, sizeof(tns__bugUpdateResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_tns__bugUpdateResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (tns__bugUpdateResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag__bugUpdateResponse1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag__bugUpdateResponse1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &(((tns__bugUpdateResponse*)a)->_bugUpdateResponse), "xsd:string"))
				{	soap_flag__bugUpdateResponse1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (tns__bugUpdateResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__bugUpdateResponse, sizeof(tns__bugUpdateResponse), soap->type, soap->arrayType), SOAP_TYPE_tns__bugUpdateResponse, sizeof(tns__bugUpdateResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 tns__bugUpdateResponse * SOAP_FMAC4 soap_new_tns__bugUpdateResponse(struct soap *soap, int n)
{	return soap_instantiate_tns__bugUpdateResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_delete_tns__bugUpdateResponse(struct soap *soap, tns__bugUpdateResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 tns__bugUpdateResponse * SOAP_FMAC4 soap_instantiate_tns__bugUpdateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__bugUpdateResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tns__bugUpdateResponse, n);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new tns__bugUpdateResponse;
		if (size)
			*size = sizeof(tns__bugUpdateResponse);
	}
	else
	{	cp->ptr = (void*)new tns__bugUpdateResponse[n];
		if (size)
			*size = n * sizeof(tns__bugUpdateResponse);
	}
	return (tns__bugUpdateResponse*)cp->ptr;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_SOAP_ENV__Fault))
		soap_mark_SOAP_ENV__Fault(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	soap_embedded(soap, &a->faultcode, SOAP_TYPE__QName);
	soap_mark__QName(soap, &a->faultcode);
	soap_embedded(soap, &a->faultstring, SOAP_TYPE_string);
	soap_mark_string(soap, &a->faultstring);
	soap_embedded(soap, &a->faultactor, SOAP_TYPE_string);
	soap_mark_string(soap, &a->faultactor);
	soap_embedded(soap, &a->detail, SOAP_TYPE_string);
	soap_mark_string(soap, &a->detail);
	soap_embedded(soap, &a->SOAP_ENV__Code, SOAP_TYPE_PointerToSOAP_ENV__Code);
	soap_mark_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_embedded(soap, &a->SOAP_ENV__Reason, SOAP_TYPE_string);
	soap_mark_string(soap, &a->SOAP_ENV__Reason);
	soap_embedded(soap, &a->SOAP_ENV__Detail, SOAP_TYPE_string);
	soap_mark_string(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	soap_default_string(soap, &a->detail);
	soap_default_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_default_string(soap, &a->SOAP_ENV__Reason);
	soap_default_string(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_SOAP_ENV__Fault);
	soap_out_SOAP_ENV__Fault(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type);
	soap_out__QName(soap, "faultcode", -1, &a->faultcode, "");
	soap_out_string(soap, "faultstring", -1, &a->faultstring, "");
	soap_out_string(soap, "faultactor", -1, &a->faultactor, "");
	soap_out_string(soap, "detail", -1, &a->detail, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, "");
	soap_out_string(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, "");
	soap_out_string(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	short soap_flag_faultcode = 1, soap_flag_faultstring = 1, soap_flag_faultactor = 1, soap_flag_detail = 1, soap_flag_SOAP_ENV__Code = 1, soap_flag_SOAP_ENV__Reason = 1, soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_SOAP_ENV__Fault(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode = 0;
					continue;
				}
			if (soap_flag_faultstring && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "faultstring", &a->faultstring, ""))
				{	soap_flag_faultstring = 0;
					continue;
				}
			if (soap_flag_faultactor && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "faultactor", &a->faultactor, ""))
				{	soap_flag_faultactor = 0;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "detail", &a->detail, ""))
				{	soap_flag_detail = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0), SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault));
		if (soap->alloced)
			soap_default_SOAP_ENV__Fault(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_SOAP_ENV__Code))
		soap_mark_SOAP_ENV__Code(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	soap_embedded(soap, &a->SOAP_ENV__Value, SOAP_TYPE__QName);
	soap_mark__QName(soap, &a->SOAP_ENV__Value);
	soap_embedded(soap, &a->SOAP_ENV__Node, SOAP_TYPE_string);
	soap_mark_string(soap, &a->SOAP_ENV__Node);
	soap_embedded(soap, &a->SOAP_ENV__Role, SOAP_TYPE_string);
	soap_mark_string(soap, &a->SOAP_ENV__Role);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_SOAP_ENV__Code);
	soap_out_SOAP_ENV__Code(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type);
	soap_out__QName(soap, "SOAP-ENV:Value", -1, &a->SOAP_ENV__Value, "");
	soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, "");
	soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	short soap_flag_SOAP_ENV__Value = 1, soap_flag_SOAP_ENV__Node = 1, soap_flag_SOAP_ENV__Role = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_SOAP_ENV__Code(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, ""))
				{	soap_flag_SOAP_ENV__Node = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, ""))
				{	soap_flag_SOAP_ENV__Role = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0), SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code));
		if (soap->alloced)
			soap_default_SOAP_ENV__Code(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_SOAP_ENV__Header))
		soap_mark_SOAP_ENV__Header(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	/* transient dummy skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	/* transient dummy skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_SOAP_ENV__Header);
	soap_out_SOAP_ENV__Header(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type);
	/* transient dummy skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_SOAP_ENV__Header(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
		/* transient dummy skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0), SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header));
		if (soap->alloced)
			soap_default_SOAP_ENV__Header(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tns__bugFetch(struct soap *soap, struct tns__bugFetch const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__bugFetch))
		soap_mark_tns__bugFetch(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_tns__bugFetch(struct soap *soap, const struct tns__bugFetch *a)
{
	soap_embedded(soap, &a->sessionkey, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->sessionkey);
	soap_embedded(soap, &a->project, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->project);
	soap_embedded(soap, &a->bugid, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->bugid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tns__bugFetch(struct soap *soap, struct tns__bugFetch *a)
{
	soap_default_xsd__string(soap, &a->sessionkey);
	soap_default_xsd__string(soap, &a->project);
	soap_default_xsd__string(soap, &a->bugid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tns__bugFetch(struct soap *soap, struct tns__bugFetch *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_tns__bugFetch);
	soap_out_tns__bugFetch(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__bugFetch(struct soap *soap, const char *tag, int id, const struct tns__bugFetch *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__bugFetch), type);
	soap_out_xsd__string(soap, "sessionkey", -1, &a->sessionkey, "xsd:string");
	soap_out_xsd__string(soap, "project", -1, &a->project, "xsd:string");
	soap_out_xsd__string(soap, "bugid", -1, &a->bugid, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct tns__bugFetch * SOAP_FMAC4 soap_get_tns__bugFetch(struct soap *soap, struct tns__bugFetch *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__bugFetch(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct tns__bugFetch * SOAP_FMAC4 soap_in_tns__bugFetch(struct soap *soap, const char *tag, struct tns__bugFetch *a, const char *type)
{
	short soap_flag_sessionkey = 1, soap_flag_project = 1, soap_flag_bugid = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__bugFetch *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__bugFetch, sizeof(struct tns__bugFetch), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__bugFetch(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sessionkey && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "sessionkey", &a->sessionkey, "xsd:string"))
				{	soap_flag_sessionkey = 0;
					continue;
				}
			if (soap_flag_project && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "project", &a->project, "xsd:string"))
				{	soap_flag_project = 0;
					continue;
				}
			if (soap_flag_bugid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "bugid", &a->bugid, "xsd:string"))
				{	soap_flag_bugid = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__bugFetch *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__bugFetch, sizeof(struct tns__bugFetch), 0), SOAP_TYPE_tns__bugFetch, sizeof(struct tns__bugFetch));
		if (soap->alloced)
			soap_default_tns__bugFetch(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tns__getNumberOfHostedProjects(struct soap *soap, struct tns__getNumberOfHostedProjects const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__getNumberOfHostedProjects))
		soap_mark_tns__getNumberOfHostedProjects(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_tns__getNumberOfHostedProjects(struct soap *soap, const struct tns__getNumberOfHostedProjects *a)
{
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tns__getNumberOfHostedProjects(struct soap *soap, struct tns__getNumberOfHostedProjects *a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tns__getNumberOfHostedProjects(struct soap *soap, struct tns__getNumberOfHostedProjects *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_tns__getNumberOfHostedProjects);
	soap_out_tns__getNumberOfHostedProjects(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__getNumberOfHostedProjects(struct soap *soap, const char *tag, int id, const struct tns__getNumberOfHostedProjects *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__getNumberOfHostedProjects), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct tns__getNumberOfHostedProjects * SOAP_FMAC4 soap_get_tns__getNumberOfHostedProjects(struct soap *soap, struct tns__getNumberOfHostedProjects *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__getNumberOfHostedProjects(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct tns__getNumberOfHostedProjects * SOAP_FMAC4 soap_in_tns__getNumberOfHostedProjects(struct soap *soap, const char *tag, struct tns__getNumberOfHostedProjects *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__getNumberOfHostedProjects *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__getNumberOfHostedProjects, sizeof(struct tns__getNumberOfHostedProjects), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__getNumberOfHostedProjects(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__getNumberOfHostedProjects *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__getNumberOfHostedProjects, sizeof(struct tns__getNumberOfHostedProjects), 0), SOAP_TYPE_tns__getNumberOfHostedProjects, sizeof(struct tns__getNumberOfHostedProjects));
		if (soap->alloced)
			soap_default_tns__getNumberOfHostedProjects(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tns__bugAdd(struct soap *soap, struct tns__bugAdd const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__bugAdd))
		soap_mark_tns__bugAdd(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_tns__bugAdd(struct soap *soap, const struct tns__bugAdd *a)
{
	soap_embedded(soap, &a->sessionkey, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->sessionkey);
	soap_embedded(soap, &a->project, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->project);
	soap_embedded(soap, &a->summary, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->summary);
	soap_embedded(soap, &a->details, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->details);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tns__bugAdd(struct soap *soap, struct tns__bugAdd *a)
{
	soap_default_xsd__string(soap, &a->sessionkey);
	soap_default_xsd__string(soap, &a->project);
	soap_default_xsd__string(soap, &a->summary);
	soap_default_xsd__string(soap, &a->details);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tns__bugAdd(struct soap *soap, struct tns__bugAdd *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_tns__bugAdd);
	soap_out_tns__bugAdd(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__bugAdd(struct soap *soap, const char *tag, int id, const struct tns__bugAdd *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__bugAdd), type);
	soap_out_xsd__string(soap, "sessionkey", -1, &a->sessionkey, "xsd:string");
	soap_out_xsd__string(soap, "project", -1, &a->project, "xsd:string");
	soap_out_xsd__string(soap, "summary", -1, &a->summary, "xsd:string");
	soap_out_xsd__string(soap, "details", -1, &a->details, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct tns__bugAdd * SOAP_FMAC4 soap_get_tns__bugAdd(struct soap *soap, struct tns__bugAdd *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__bugAdd(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct tns__bugAdd * SOAP_FMAC4 soap_in_tns__bugAdd(struct soap *soap, const char *tag, struct tns__bugAdd *a, const char *type)
{
	short soap_flag_sessionkey = 1, soap_flag_project = 1, soap_flag_summary = 1, soap_flag_details = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__bugAdd *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__bugAdd, sizeof(struct tns__bugAdd), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__bugAdd(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sessionkey && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "sessionkey", &a->sessionkey, "xsd:string"))
				{	soap_flag_sessionkey = 0;
					continue;
				}
			if (soap_flag_project && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "project", &a->project, "xsd:string"))
				{	soap_flag_project = 0;
					continue;
				}
			if (soap_flag_summary && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "summary", &a->summary, "xsd:string"))
				{	soap_flag_summary = 0;
					continue;
				}
			if (soap_flag_details && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "details", &a->details, "xsd:string"))
				{	soap_flag_details = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__bugAdd *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__bugAdd, sizeof(struct tns__bugAdd), 0), SOAP_TYPE_tns__bugAdd, sizeof(struct tns__bugAdd));
		if (soap->alloced)
			soap_default_tns__bugAdd(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tns__login(struct soap *soap, struct tns__login const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__login))
		soap_mark_tns__login(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_tns__login(struct soap *soap, const struct tns__login *a)
{
	soap_embedded(soap, &a->userid, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->userid);
	soap_embedded(soap, &a->passwd, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->passwd);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tns__login(struct soap *soap, struct tns__login *a)
{
	soap_default_xsd__string(soap, &a->userid);
	soap_default_xsd__string(soap, &a->passwd);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tns__login(struct soap *soap, struct tns__login *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_tns__login);
	soap_out_tns__login(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__login(struct soap *soap, const char *tag, int id, const struct tns__login *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__login), type);
	soap_out_xsd__string(soap, "userid", -1, &a->userid, "xsd:string");
	soap_out_xsd__string(soap, "passwd", -1, &a->passwd, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct tns__login * SOAP_FMAC4 soap_get_tns__login(struct soap *soap, struct tns__login *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__login(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct tns__login * SOAP_FMAC4 soap_in_tns__login(struct soap *soap, const char *tag, struct tns__login *a, const char *type)
{
	short soap_flag_userid = 1, soap_flag_passwd = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__login *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__login, sizeof(struct tns__login), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__login(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "userid", &a->userid, "xsd:string"))
				{	soap_flag_userid = 0;
					continue;
				}
			if (soap_flag_passwd && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "passwd", &a->passwd, "xsd:string"))
				{	soap_flag_passwd = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__login *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__login, sizeof(struct tns__login), 0), SOAP_TYPE_tns__login, sizeof(struct tns__login));
		if (soap->alloced)
			soap_default_tns__login(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tns__getSiteStats(struct soap *soap, struct tns__getSiteStats const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__getSiteStats))
		soap_mark_tns__getSiteStats(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_tns__getSiteStats(struct soap *soap, const struct tns__getSiteStats *a)
{
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tns__getSiteStats(struct soap *soap, struct tns__getSiteStats *a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tns__getSiteStats(struct soap *soap, struct tns__getSiteStats *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_tns__getSiteStats);
	soap_out_tns__getSiteStats(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__getSiteStats(struct soap *soap, const char *tag, int id, const struct tns__getSiteStats *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__getSiteStats), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct tns__getSiteStats * SOAP_FMAC4 soap_get_tns__getSiteStats(struct soap *soap, struct tns__getSiteStats *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__getSiteStats(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct tns__getSiteStats * SOAP_FMAC4 soap_in_tns__getSiteStats(struct soap *soap, const char *tag, struct tns__getSiteStats *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__getSiteStats *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__getSiteStats, sizeof(struct tns__getSiteStats), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__getSiteStats(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__getSiteStats *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__getSiteStats, sizeof(struct tns__getSiteStats), 0), SOAP_TYPE_tns__getSiteStats, sizeof(struct tns__getSiteStats));
		if (soap->alloced)
			soap_default_tns__getSiteStats(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tns__getPublicProjectNames(struct soap *soap, struct tns__getPublicProjectNames const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__getPublicProjectNames))
		soap_mark_tns__getPublicProjectNames(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_tns__getPublicProjectNames(struct soap *soap, const struct tns__getPublicProjectNames *a)
{
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tns__getPublicProjectNames(struct soap *soap, struct tns__getPublicProjectNames *a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tns__getPublicProjectNames(struct soap *soap, struct tns__getPublicProjectNames *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_tns__getPublicProjectNames);
	soap_out_tns__getPublicProjectNames(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__getPublicProjectNames(struct soap *soap, const char *tag, int id, const struct tns__getPublicProjectNames *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__getPublicProjectNames), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct tns__getPublicProjectNames * SOAP_FMAC4 soap_get_tns__getPublicProjectNames(struct soap *soap, struct tns__getPublicProjectNames *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__getPublicProjectNames(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct tns__getPublicProjectNames * SOAP_FMAC4 soap_in_tns__getPublicProjectNames(struct soap *soap, const char *tag, struct tns__getPublicProjectNames *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__getPublicProjectNames *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__getPublicProjectNames, sizeof(struct tns__getPublicProjectNames), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__getPublicProjectNames(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__getPublicProjectNames *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__getPublicProjectNames, sizeof(struct tns__getPublicProjectNames), 0), SOAP_TYPE_tns__getPublicProjectNames, sizeof(struct tns__getPublicProjectNames));
		if (soap->alloced)
			soap_default_tns__getPublicProjectNames(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tns__group(struct soap *soap, struct tns__group const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__group))
		soap_mark_tns__group(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_tns__group(struct soap *soap, const struct tns__group *a)
{
	soap_embedded(soap, &a->func, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->func);
	soap_embedded(soap, &a->params, SOAP_TYPE_PointerTotns__ArrayOfstring);
	soap_mark_PointerTotns__ArrayOfstring(soap, &a->params);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tns__group(struct soap *soap, struct tns__group *a)
{
	soap_default_xsd__string(soap, &a->func);
	soap_default_PointerTotns__ArrayOfstring(soap, &a->params);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tns__group(struct soap *soap, struct tns__group *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_tns__group);
	soap_out_tns__group(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__group(struct soap *soap, const char *tag, int id, const struct tns__group *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__group), type);
	soap_out_xsd__string(soap, "func", -1, &a->func, "xsd:string");
	soap_out_PointerTotns__ArrayOfstring(soap, "params", -1, &a->params, "tns:ArrayOfstring");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct tns__group * SOAP_FMAC4 soap_get_tns__group(struct soap *soap, struct tns__group *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__group(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct tns__group * SOAP_FMAC4 soap_in_tns__group(struct soap *soap, const char *tag, struct tns__group *a, const char *type)
{
	short soap_flag_func = 1, soap_flag_params = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__group *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__group, sizeof(struct tns__group), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__group(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_func && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "func", &a->func, "xsd:string"))
				{	soap_flag_func = 0;
					continue;
				}
			if (soap_flag_params && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__ArrayOfstring(soap, "params", &a->params, "tns:ArrayOfstring"))
				{	soap_flag_params = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__group *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__group, sizeof(struct tns__group), 0), SOAP_TYPE_tns__group, sizeof(struct tns__group));
		if (soap->alloced)
			soap_default_tns__group(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tns__bugUpdate(struct soap *soap, struct tns__bugUpdate const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__bugUpdate))
		soap_mark_tns__bugUpdate(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_tns__bugUpdate(struct soap *soap, const struct tns__bugUpdate *a)
{
	soap_embedded(soap, &a->sessionkey, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->sessionkey);
	soap_embedded(soap, &a->project, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->project);
	soap_embedded(soap, &a->bugid, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->bugid);
	soap_embedded(soap, &a->comment, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->comment);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tns__bugUpdate(struct soap *soap, struct tns__bugUpdate *a)
{
	soap_default_xsd__string(soap, &a->sessionkey);
	soap_default_xsd__string(soap, &a->project);
	soap_default_xsd__string(soap, &a->bugid);
	soap_default_xsd__string(soap, &a->comment);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tns__bugUpdate(struct soap *soap, struct tns__bugUpdate *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_tns__bugUpdate);
	soap_out_tns__bugUpdate(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__bugUpdate(struct soap *soap, const char *tag, int id, const struct tns__bugUpdate *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__bugUpdate), type);
	soap_out_xsd__string(soap, "sessionkey", -1, &a->sessionkey, "xsd:string");
	soap_out_xsd__string(soap, "project", -1, &a->project, "xsd:string");
	soap_out_xsd__string(soap, "bugid", -1, &a->bugid, "xsd:string");
	soap_out_xsd__string(soap, "comment", -1, &a->comment, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct tns__bugUpdate * SOAP_FMAC4 soap_get_tns__bugUpdate(struct soap *soap, struct tns__bugUpdate *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__bugUpdate(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct tns__bugUpdate * SOAP_FMAC4 soap_in_tns__bugUpdate(struct soap *soap, const char *tag, struct tns__bugUpdate *a, const char *type)
{
	short soap_flag_sessionkey = 1, soap_flag_project = 1, soap_flag_bugid = 1, soap_flag_comment = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__bugUpdate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__bugUpdate, sizeof(struct tns__bugUpdate), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__bugUpdate(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sessionkey && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "sessionkey", &a->sessionkey, "xsd:string"))
				{	soap_flag_sessionkey = 0;
					continue;
				}
			if (soap_flag_project && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "project", &a->project, "xsd:string"))
				{	soap_flag_project = 0;
					continue;
				}
			if (soap_flag_bugid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "bugid", &a->bugid, "xsd:string"))
				{	soap_flag_bugid = 0;
					continue;
				}
			if (soap_flag_comment && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "comment", &a->comment, "xsd:string"))
				{	soap_flag_comment = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__bugUpdate *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__bugUpdate, sizeof(struct tns__bugUpdate), 0), SOAP_TYPE_tns__bugUpdate, sizeof(struct tns__bugUpdate));
		if (soap->alloced)
			soap_default_tns__bugUpdate(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tns__bugList(struct soap *soap, struct tns__bugList const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__bugList))
		soap_mark_tns__bugList(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_tns__bugList(struct soap *soap, const struct tns__bugList *a)
{
	soap_embedded(soap, &a->sessionkey, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->sessionkey);
	soap_embedded(soap, &a->project, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->project);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tns__bugList(struct soap *soap, struct tns__bugList *a)
{
	soap_default_xsd__string(soap, &a->sessionkey);
	soap_default_xsd__string(soap, &a->project);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tns__bugList(struct soap *soap, struct tns__bugList *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_tns__bugList);
	soap_out_tns__bugList(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__bugList(struct soap *soap, const char *tag, int id, const struct tns__bugList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__bugList), type);
	soap_out_xsd__string(soap, "sessionkey", -1, &a->sessionkey, "xsd:string");
	soap_out_xsd__string(soap, "project", -1, &a->project, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct tns__bugList * SOAP_FMAC4 soap_get_tns__bugList(struct soap *soap, struct tns__bugList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__bugList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct tns__bugList * SOAP_FMAC4 soap_in_tns__bugList(struct soap *soap, const char *tag, struct tns__bugList *a, const char *type)
{
	short soap_flag_sessionkey = 1, soap_flag_project = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__bugList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__bugList, sizeof(struct tns__bugList), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__bugList(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sessionkey && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "sessionkey", &a->sessionkey, "xsd:string"))
				{	soap_flag_sessionkey = 0;
					continue;
				}
			if (soap_flag_project && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "project", &a->project, "xsd:string"))
				{	soap_flag_project = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__bugList *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__bugList, sizeof(struct tns__bugList), 0), SOAP_TYPE_tns__bugList, sizeof(struct tns__bugList));
		if (soap->alloced)
			soap_default_tns__bugList(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tns__getNumberOfActiveUsers(struct soap *soap, struct tns__getNumberOfActiveUsers const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__getNumberOfActiveUsers))
		soap_mark_tns__getNumberOfActiveUsers(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_tns__getNumberOfActiveUsers(struct soap *soap, const struct tns__getNumberOfActiveUsers *a)
{
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tns__getNumberOfActiveUsers(struct soap *soap, struct tns__getNumberOfActiveUsers *a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tns__getNumberOfActiveUsers(struct soap *soap, struct tns__getNumberOfActiveUsers *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_tns__getNumberOfActiveUsers);
	soap_out_tns__getNumberOfActiveUsers(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__getNumberOfActiveUsers(struct soap *soap, const char *tag, int id, const struct tns__getNumberOfActiveUsers *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__getNumberOfActiveUsers), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct tns__getNumberOfActiveUsers * SOAP_FMAC4 soap_get_tns__getNumberOfActiveUsers(struct soap *soap, struct tns__getNumberOfActiveUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__getNumberOfActiveUsers(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct tns__getNumberOfActiveUsers * SOAP_FMAC4 soap_in_tns__getNumberOfActiveUsers(struct soap *soap, const char *tag, struct tns__getNumberOfActiveUsers *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__getNumberOfActiveUsers *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__getNumberOfActiveUsers, sizeof(struct tns__getNumberOfActiveUsers), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__getNumberOfActiveUsers(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__getNumberOfActiveUsers *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__getNumberOfActiveUsers, sizeof(struct tns__getNumberOfActiveUsers), 0), SOAP_TYPE_tns__getNumberOfActiveUsers, sizeof(struct tns__getNumberOfActiveUsers));
		if (soap->alloced)
			soap_default_tns__getNumberOfActiveUsers(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tns__hello(struct soap *soap, struct tns__hello const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__hello))
		soap_mark_tns__hello(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_tns__hello(struct soap *soap, const struct tns__hello *a)
{
	soap_embedded(soap, &a->parm, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->parm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tns__hello(struct soap *soap, struct tns__hello *a)
{
	soap_default_xsd__string(soap, &a->parm);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tns__hello(struct soap *soap, struct tns__hello *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_tns__hello);
	soap_out_tns__hello(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__hello(struct soap *soap, const char *tag, int id, const struct tns__hello *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__hello), type);
	soap_out_xsd__string(soap, "parm", -1, &a->parm, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct tns__hello * SOAP_FMAC4 soap_get_tns__hello(struct soap *soap, struct tns__hello *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__hello(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct tns__hello * SOAP_FMAC4 soap_in_tns__hello(struct soap *soap, const char *tag, struct tns__hello *a, const char *type)
{
	short soap_flag_parm = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__hello *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__hello, sizeof(struct tns__hello), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__hello(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_parm && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "parm", &a->parm, "xsd:string"))
				{	soap_flag_parm = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__hello *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__hello, sizeof(struct tns__hello), 0), SOAP_TYPE_tns__hello, sizeof(struct tns__hello));
		if (soap->alloced)
			soap_default_tns__hello(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tns__logout(struct soap *soap, struct tns__logout const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__logout))
		soap_mark_tns__logout(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_tns__logout(struct soap *soap, const struct tns__logout *a)
{
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tns__logout(struct soap *soap, struct tns__logout *a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tns__logout(struct soap *soap, struct tns__logout *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_tns__logout);
	soap_out_tns__logout(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__logout(struct soap *soap, const char *tag, int id, const struct tns__logout *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__logout), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct tns__logout * SOAP_FMAC4 soap_get_tns__logout(struct soap *soap, struct tns__logout *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__logout(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct tns__logout * SOAP_FMAC4 soap_in_tns__logout(struct soap *soap, const char *tag, struct tns__logout *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__logout *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__logout, sizeof(struct tns__logout), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__logout(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__logout *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__logout, sizeof(struct tns__logout), 0), SOAP_TYPE_tns__logout, sizeof(struct tns__logout));
		if (soap->alloced)
			soap_default_tns__logout(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tns__user(struct soap *soap, struct tns__user const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__user))
		soap_mark_tns__user(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_tns__user(struct soap *soap, const struct tns__user *a)
{
	soap_embedded(soap, &a->func, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->func);
	soap_embedded(soap, &a->params, SOAP_TYPE_PointerTotns__ArrayOfstring);
	soap_mark_PointerTotns__ArrayOfstring(soap, &a->params);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tns__user(struct soap *soap, struct tns__user *a)
{
	soap_default_xsd__string(soap, &a->func);
	soap_default_PointerTotns__ArrayOfstring(soap, &a->params);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tns__user(struct soap *soap, struct tns__user *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_tns__user);
	soap_out_tns__user(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__user(struct soap *soap, const char *tag, int id, const struct tns__user *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__user), type);
	soap_out_xsd__string(soap, "func", -1, &a->func, "xsd:string");
	soap_out_PointerTotns__ArrayOfstring(soap, "params", -1, &a->params, "tns:ArrayOfstring");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct tns__user * SOAP_FMAC4 soap_get_tns__user(struct soap *soap, struct tns__user *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__user(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct tns__user * SOAP_FMAC4 soap_in_tns__user(struct soap *soap, const char *tag, struct tns__user *a, const char *type)
{
	short soap_flag_func = 1, soap_flag_params = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__user *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__user, sizeof(struct tns__user), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__user(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_func && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "func", &a->func, "xsd:string"))
				{	soap_flag_func = 0;
					continue;
				}
			if (soap_flag_params && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__ArrayOfstring(soap, "params", &a->params, "tns:ArrayOfstring"))
				{	soap_flag_params = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__user *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__user, sizeof(struct tns__user), 0), SOAP_TYPE_tns__user, sizeof(struct tns__user));
		if (soap->alloced)
			soap_default_tns__user(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerToSOAP_ENV__Code))
		soap_mark_PointerToSOAP_ENV__Code(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_mark_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	soap_out_PointerToSOAP_ENV__Code(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_SOAP_ENV__Code, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_SOAP_ENV__Code(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_SOAP_ENV__Code(soap, tag, i, *a, type);
	}
	return soap_out_SOAP_ENV__Code(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_SOAP_ENV__Code, &pp), *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	struct SOAP_ENV__Code *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct SOAP_ENV__Code **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerToSOAP_ENV__Code, sizeof(struct SOAP_ENV__Code *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_SOAP_ENV__Code(soap, tag, NULL, type)))
		{	a = (struct SOAP_ENV__Code **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerToSOAP_ENV__Code, sizeof(struct SOAP_ENV__Code *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerToSOAP_ENV__Code, sizeof(struct SOAP_ENV__Code *), 1), SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__bugFetchResponse(struct soap *soap, tns__bugFetchResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__bugFetchResponse))
		soap_mark_PointerTotns__bugFetchResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTotns__bugFetchResponse(struct soap *soap, tns__bugFetchResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__bugFetchResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTotns__bugFetchResponse(struct soap *soap, tns__bugFetchResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__bugFetchResponse(struct soap *soap, tns__bugFetchResponse **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTotns__bugFetchResponse);
	soap_out_PointerTotns__bugFetchResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__bugFetchResponse(struct soap *soap, const char *tag, int id, tns__bugFetchResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__bugFetchResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__bugFetchResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__bugFetchResponse, &pp), type);
}

SOAP_FMAC3 tns__bugFetchResponse ** SOAP_FMAC4 soap_get_PointerTotns__bugFetchResponse(struct soap *soap, tns__bugFetchResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__bugFetchResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 tns__bugFetchResponse ** SOAP_FMAC4 soap_in_PointerTotns__bugFetchResponse(struct soap *soap, const char *tag, tns__bugFetchResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (tns__bugFetchResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__bugFetchResponse, sizeof(tns__bugFetchResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (tns__bugFetchResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTotns__bugFetchResponse, sizeof(tns__bugFetchResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (tns__bugFetchResponse *)soap_instantiate_tns__bugFetchResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (tns__bugFetchResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__bugFetchResponse, sizeof(tns__bugFetchResponse *), 1), SOAP_TYPE_tns__bugFetchResponse, sizeof(tns__bugFetchResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__getNumberOfHostedProjectsResponse(struct soap *soap, tns__getNumberOfHostedProjectsResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__getNumberOfHostedProjectsResponse))
		soap_mark_PointerTotns__getNumberOfHostedProjectsResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTotns__getNumberOfHostedProjectsResponse(struct soap *soap, tns__getNumberOfHostedProjectsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__getNumberOfHostedProjectsResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTotns__getNumberOfHostedProjectsResponse(struct soap *soap, tns__getNumberOfHostedProjectsResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__getNumberOfHostedProjectsResponse(struct soap *soap, tns__getNumberOfHostedProjectsResponse **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTotns__getNumberOfHostedProjectsResponse);
	soap_out_PointerTotns__getNumberOfHostedProjectsResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__getNumberOfHostedProjectsResponse(struct soap *soap, const char *tag, int id, tns__getNumberOfHostedProjectsResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__getNumberOfHostedProjectsResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__getNumberOfHostedProjectsResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__getNumberOfHostedProjectsResponse, &pp), type);
}

SOAP_FMAC3 tns__getNumberOfHostedProjectsResponse ** SOAP_FMAC4 soap_get_PointerTotns__getNumberOfHostedProjectsResponse(struct soap *soap, tns__getNumberOfHostedProjectsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__getNumberOfHostedProjectsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 tns__getNumberOfHostedProjectsResponse ** SOAP_FMAC4 soap_in_PointerTotns__getNumberOfHostedProjectsResponse(struct soap *soap, const char *tag, tns__getNumberOfHostedProjectsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (tns__getNumberOfHostedProjectsResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__getNumberOfHostedProjectsResponse, sizeof(tns__getNumberOfHostedProjectsResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (tns__getNumberOfHostedProjectsResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTotns__getNumberOfHostedProjectsResponse, sizeof(tns__getNumberOfHostedProjectsResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (tns__getNumberOfHostedProjectsResponse *)soap_instantiate_tns__getNumberOfHostedProjectsResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (tns__getNumberOfHostedProjectsResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__getNumberOfHostedProjectsResponse, sizeof(tns__getNumberOfHostedProjectsResponse *), 1), SOAP_TYPE_tns__getNumberOfHostedProjectsResponse, sizeof(tns__getNumberOfHostedProjectsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__bugAddResponse(struct soap *soap, tns__bugAddResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__bugAddResponse))
		soap_mark_PointerTotns__bugAddResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTotns__bugAddResponse(struct soap *soap, tns__bugAddResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__bugAddResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTotns__bugAddResponse(struct soap *soap, tns__bugAddResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__bugAddResponse(struct soap *soap, tns__bugAddResponse **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTotns__bugAddResponse);
	soap_out_PointerTotns__bugAddResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__bugAddResponse(struct soap *soap, const char *tag, int id, tns__bugAddResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__bugAddResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__bugAddResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__bugAddResponse, &pp), type);
}

SOAP_FMAC3 tns__bugAddResponse ** SOAP_FMAC4 soap_get_PointerTotns__bugAddResponse(struct soap *soap, tns__bugAddResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__bugAddResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 tns__bugAddResponse ** SOAP_FMAC4 soap_in_PointerTotns__bugAddResponse(struct soap *soap, const char *tag, tns__bugAddResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (tns__bugAddResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__bugAddResponse, sizeof(tns__bugAddResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (tns__bugAddResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTotns__bugAddResponse, sizeof(tns__bugAddResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (tns__bugAddResponse *)soap_instantiate_tns__bugAddResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (tns__bugAddResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__bugAddResponse, sizeof(tns__bugAddResponse *), 1), SOAP_TYPE_tns__bugAddResponse, sizeof(tns__bugAddResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__loginResponse(struct soap *soap, tns__loginResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__loginResponse))
		soap_mark_PointerTotns__loginResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTotns__loginResponse(struct soap *soap, tns__loginResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__loginResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTotns__loginResponse(struct soap *soap, tns__loginResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__loginResponse(struct soap *soap, tns__loginResponse **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTotns__loginResponse);
	soap_out_PointerTotns__loginResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__loginResponse(struct soap *soap, const char *tag, int id, tns__loginResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__loginResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__loginResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__loginResponse, &pp), type);
}

SOAP_FMAC3 tns__loginResponse ** SOAP_FMAC4 soap_get_PointerTotns__loginResponse(struct soap *soap, tns__loginResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__loginResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 tns__loginResponse ** SOAP_FMAC4 soap_in_PointerTotns__loginResponse(struct soap *soap, const char *tag, tns__loginResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (tns__loginResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__loginResponse, sizeof(tns__loginResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (tns__loginResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTotns__loginResponse, sizeof(tns__loginResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (tns__loginResponse *)soap_instantiate_tns__loginResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (tns__loginResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__loginResponse, sizeof(tns__loginResponse *), 1), SOAP_TYPE_tns__loginResponse, sizeof(tns__loginResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__getSiteStatsResponse(struct soap *soap, tns__getSiteStatsResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__getSiteStatsResponse))
		soap_mark_PointerTotns__getSiteStatsResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTotns__getSiteStatsResponse(struct soap *soap, tns__getSiteStatsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__getSiteStatsResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTotns__getSiteStatsResponse(struct soap *soap, tns__getSiteStatsResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__getSiteStatsResponse(struct soap *soap, tns__getSiteStatsResponse **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTotns__getSiteStatsResponse);
	soap_out_PointerTotns__getSiteStatsResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__getSiteStatsResponse(struct soap *soap, const char *tag, int id, tns__getSiteStatsResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__getSiteStatsResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__getSiteStatsResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__getSiteStatsResponse, &pp), type);
}

SOAP_FMAC3 tns__getSiteStatsResponse ** SOAP_FMAC4 soap_get_PointerTotns__getSiteStatsResponse(struct soap *soap, tns__getSiteStatsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__getSiteStatsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 tns__getSiteStatsResponse ** SOAP_FMAC4 soap_in_PointerTotns__getSiteStatsResponse(struct soap *soap, const char *tag, tns__getSiteStatsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (tns__getSiteStatsResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__getSiteStatsResponse, sizeof(tns__getSiteStatsResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (tns__getSiteStatsResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTotns__getSiteStatsResponse, sizeof(tns__getSiteStatsResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (tns__getSiteStatsResponse *)soap_instantiate_tns__getSiteStatsResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (tns__getSiteStatsResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__getSiteStatsResponse, sizeof(tns__getSiteStatsResponse *), 1), SOAP_TYPE_tns__getSiteStatsResponse, sizeof(tns__getSiteStatsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__getPublicProjectNamesResponse(struct soap *soap, tns__getPublicProjectNamesResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__getPublicProjectNamesResponse))
		soap_mark_PointerTotns__getPublicProjectNamesResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTotns__getPublicProjectNamesResponse(struct soap *soap, tns__getPublicProjectNamesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__getPublicProjectNamesResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTotns__getPublicProjectNamesResponse(struct soap *soap, tns__getPublicProjectNamesResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__getPublicProjectNamesResponse(struct soap *soap, tns__getPublicProjectNamesResponse **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTotns__getPublicProjectNamesResponse);
	soap_out_PointerTotns__getPublicProjectNamesResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__getPublicProjectNamesResponse(struct soap *soap, const char *tag, int id, tns__getPublicProjectNamesResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__getPublicProjectNamesResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__getPublicProjectNamesResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__getPublicProjectNamesResponse, &pp), type);
}

SOAP_FMAC3 tns__getPublicProjectNamesResponse ** SOAP_FMAC4 soap_get_PointerTotns__getPublicProjectNamesResponse(struct soap *soap, tns__getPublicProjectNamesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__getPublicProjectNamesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 tns__getPublicProjectNamesResponse ** SOAP_FMAC4 soap_in_PointerTotns__getPublicProjectNamesResponse(struct soap *soap, const char *tag, tns__getPublicProjectNamesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (tns__getPublicProjectNamesResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__getPublicProjectNamesResponse, sizeof(tns__getPublicProjectNamesResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (tns__getPublicProjectNamesResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTotns__getPublicProjectNamesResponse, sizeof(tns__getPublicProjectNamesResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (tns__getPublicProjectNamesResponse *)soap_instantiate_tns__getPublicProjectNamesResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (tns__getPublicProjectNamesResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__getPublicProjectNamesResponse, sizeof(tns__getPublicProjectNamesResponse *), 1), SOAP_TYPE_tns__getPublicProjectNamesResponse, sizeof(tns__getPublicProjectNamesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__groupResponse(struct soap *soap, tns__groupResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__groupResponse))
		soap_mark_PointerTotns__groupResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTotns__groupResponse(struct soap *soap, tns__groupResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__groupResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTotns__groupResponse(struct soap *soap, tns__groupResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__groupResponse(struct soap *soap, tns__groupResponse **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTotns__groupResponse);
	soap_out_PointerTotns__groupResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__groupResponse(struct soap *soap, const char *tag, int id, tns__groupResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__groupResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__groupResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__groupResponse, &pp), type);
}

SOAP_FMAC3 tns__groupResponse ** SOAP_FMAC4 soap_get_PointerTotns__groupResponse(struct soap *soap, tns__groupResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__groupResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 tns__groupResponse ** SOAP_FMAC4 soap_in_PointerTotns__groupResponse(struct soap *soap, const char *tag, tns__groupResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (tns__groupResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__groupResponse, sizeof(tns__groupResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (tns__groupResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTotns__groupResponse, sizeof(tns__groupResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (tns__groupResponse *)soap_instantiate_tns__groupResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (tns__groupResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__groupResponse, sizeof(tns__groupResponse *), 1), SOAP_TYPE_tns__groupResponse, sizeof(tns__groupResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__bugUpdateResponse(struct soap *soap, tns__bugUpdateResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__bugUpdateResponse))
		soap_mark_PointerTotns__bugUpdateResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTotns__bugUpdateResponse(struct soap *soap, tns__bugUpdateResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__bugUpdateResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTotns__bugUpdateResponse(struct soap *soap, tns__bugUpdateResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__bugUpdateResponse(struct soap *soap, tns__bugUpdateResponse **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTotns__bugUpdateResponse);
	soap_out_PointerTotns__bugUpdateResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__bugUpdateResponse(struct soap *soap, const char *tag, int id, tns__bugUpdateResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__bugUpdateResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__bugUpdateResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__bugUpdateResponse, &pp), type);
}

SOAP_FMAC3 tns__bugUpdateResponse ** SOAP_FMAC4 soap_get_PointerTotns__bugUpdateResponse(struct soap *soap, tns__bugUpdateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__bugUpdateResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 tns__bugUpdateResponse ** SOAP_FMAC4 soap_in_PointerTotns__bugUpdateResponse(struct soap *soap, const char *tag, tns__bugUpdateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (tns__bugUpdateResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__bugUpdateResponse, sizeof(tns__bugUpdateResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (tns__bugUpdateResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTotns__bugUpdateResponse, sizeof(tns__bugUpdateResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (tns__bugUpdateResponse *)soap_instantiate_tns__bugUpdateResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (tns__bugUpdateResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__bugUpdateResponse, sizeof(tns__bugUpdateResponse *), 1), SOAP_TYPE_tns__bugUpdateResponse, sizeof(tns__bugUpdateResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__bugListResponse(struct soap *soap, tns__bugListResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__bugListResponse))
		soap_mark_PointerTotns__bugListResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTotns__bugListResponse(struct soap *soap, tns__bugListResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__bugListResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTotns__bugListResponse(struct soap *soap, tns__bugListResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__bugListResponse(struct soap *soap, tns__bugListResponse **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTotns__bugListResponse);
	soap_out_PointerTotns__bugListResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__bugListResponse(struct soap *soap, const char *tag, int id, tns__bugListResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__bugListResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__bugListResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__bugListResponse, &pp), type);
}

SOAP_FMAC3 tns__bugListResponse ** SOAP_FMAC4 soap_get_PointerTotns__bugListResponse(struct soap *soap, tns__bugListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__bugListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 tns__bugListResponse ** SOAP_FMAC4 soap_in_PointerTotns__bugListResponse(struct soap *soap, const char *tag, tns__bugListResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (tns__bugListResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__bugListResponse, sizeof(tns__bugListResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (tns__bugListResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTotns__bugListResponse, sizeof(tns__bugListResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (tns__bugListResponse *)soap_instantiate_tns__bugListResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (tns__bugListResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__bugListResponse, sizeof(tns__bugListResponse *), 1), SOAP_TYPE_tns__bugListResponse, sizeof(tns__bugListResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__getNumberOfActiveUsersResponse(struct soap *soap, tns__getNumberOfActiveUsersResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__getNumberOfActiveUsersResponse))
		soap_mark_PointerTotns__getNumberOfActiveUsersResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTotns__getNumberOfActiveUsersResponse(struct soap *soap, tns__getNumberOfActiveUsersResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__getNumberOfActiveUsersResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTotns__getNumberOfActiveUsersResponse(struct soap *soap, tns__getNumberOfActiveUsersResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__getNumberOfActiveUsersResponse(struct soap *soap, tns__getNumberOfActiveUsersResponse **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTotns__getNumberOfActiveUsersResponse);
	soap_out_PointerTotns__getNumberOfActiveUsersResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__getNumberOfActiveUsersResponse(struct soap *soap, const char *tag, int id, tns__getNumberOfActiveUsersResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__getNumberOfActiveUsersResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__getNumberOfActiveUsersResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__getNumberOfActiveUsersResponse, &pp), type);
}

SOAP_FMAC3 tns__getNumberOfActiveUsersResponse ** SOAP_FMAC4 soap_get_PointerTotns__getNumberOfActiveUsersResponse(struct soap *soap, tns__getNumberOfActiveUsersResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__getNumberOfActiveUsersResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 tns__getNumberOfActiveUsersResponse ** SOAP_FMAC4 soap_in_PointerTotns__getNumberOfActiveUsersResponse(struct soap *soap, const char *tag, tns__getNumberOfActiveUsersResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (tns__getNumberOfActiveUsersResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__getNumberOfActiveUsersResponse, sizeof(tns__getNumberOfActiveUsersResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (tns__getNumberOfActiveUsersResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTotns__getNumberOfActiveUsersResponse, sizeof(tns__getNumberOfActiveUsersResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (tns__getNumberOfActiveUsersResponse *)soap_instantiate_tns__getNumberOfActiveUsersResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (tns__getNumberOfActiveUsersResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__getNumberOfActiveUsersResponse, sizeof(tns__getNumberOfActiveUsersResponse *), 1), SOAP_TYPE_tns__getNumberOfActiveUsersResponse, sizeof(tns__getNumberOfActiveUsersResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__helloResponse(struct soap *soap, tns__helloResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__helloResponse))
		soap_mark_PointerTotns__helloResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTotns__helloResponse(struct soap *soap, tns__helloResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__helloResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTotns__helloResponse(struct soap *soap, tns__helloResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__helloResponse(struct soap *soap, tns__helloResponse **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTotns__helloResponse);
	soap_out_PointerTotns__helloResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__helloResponse(struct soap *soap, const char *tag, int id, tns__helloResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__helloResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__helloResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__helloResponse, &pp), type);
}

SOAP_FMAC3 tns__helloResponse ** SOAP_FMAC4 soap_get_PointerTotns__helloResponse(struct soap *soap, tns__helloResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__helloResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 tns__helloResponse ** SOAP_FMAC4 soap_in_PointerTotns__helloResponse(struct soap *soap, const char *tag, tns__helloResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (tns__helloResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__helloResponse, sizeof(tns__helloResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (tns__helloResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTotns__helloResponse, sizeof(tns__helloResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (tns__helloResponse *)soap_instantiate_tns__helloResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (tns__helloResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__helloResponse, sizeof(tns__helloResponse *), 1), SOAP_TYPE_tns__helloResponse, sizeof(tns__helloResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__logoutResponse(struct soap *soap, tns__logoutResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__logoutResponse))
		soap_mark_PointerTotns__logoutResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTotns__logoutResponse(struct soap *soap, tns__logoutResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__logoutResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTotns__logoutResponse(struct soap *soap, tns__logoutResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__logoutResponse(struct soap *soap, tns__logoutResponse **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTotns__logoutResponse);
	soap_out_PointerTotns__logoutResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__logoutResponse(struct soap *soap, const char *tag, int id, tns__logoutResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__logoutResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__logoutResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__logoutResponse, &pp), type);
}

SOAP_FMAC3 tns__logoutResponse ** SOAP_FMAC4 soap_get_PointerTotns__logoutResponse(struct soap *soap, tns__logoutResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__logoutResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 tns__logoutResponse ** SOAP_FMAC4 soap_in_PointerTotns__logoutResponse(struct soap *soap, const char *tag, tns__logoutResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (tns__logoutResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__logoutResponse, sizeof(tns__logoutResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (tns__logoutResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTotns__logoutResponse, sizeof(tns__logoutResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (tns__logoutResponse *)soap_instantiate_tns__logoutResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (tns__logoutResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__logoutResponse, sizeof(tns__logoutResponse *), 1), SOAP_TYPE_tns__logoutResponse, sizeof(tns__logoutResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__userResponse(struct soap *soap, tns__userResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__userResponse))
		soap_mark_PointerTotns__userResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTotns__userResponse(struct soap *soap, tns__userResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__userResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTotns__userResponse(struct soap *soap, tns__userResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__userResponse(struct soap *soap, tns__userResponse **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTotns__userResponse);
	soap_out_PointerTotns__userResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__userResponse(struct soap *soap, const char *tag, int id, tns__userResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__userResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__userResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__userResponse, &pp), type);
}

SOAP_FMAC3 tns__userResponse ** SOAP_FMAC4 soap_get_PointerTotns__userResponse(struct soap *soap, tns__userResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__userResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 tns__userResponse ** SOAP_FMAC4 soap_in_PointerTotns__userResponse(struct soap *soap, const char *tag, tns__userResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (tns__userResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__userResponse, sizeof(tns__userResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (tns__userResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTotns__userResponse, sizeof(tns__userResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (tns__userResponse *)soap_instantiate_tns__userResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (tns__userResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__userResponse, sizeof(tns__userResponse *), 1), SOAP_TYPE_tns__userResponse, sizeof(tns__userResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__SiteStatsDataPoint(struct soap *soap, tns__SiteStatsDataPoint *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__SiteStatsDataPoint))
		soap_mark_PointerTotns__SiteStatsDataPoint(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTotns__SiteStatsDataPoint(struct soap *soap, tns__SiteStatsDataPoint *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__SiteStatsDataPoint))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTotns__SiteStatsDataPoint(struct soap *soap, tns__SiteStatsDataPoint **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__SiteStatsDataPoint(struct soap *soap, tns__SiteStatsDataPoint **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTotns__SiteStatsDataPoint);
	soap_out_PointerTotns__SiteStatsDataPoint(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__SiteStatsDataPoint(struct soap *soap, const char *tag, int id, tns__SiteStatsDataPoint *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__SiteStatsDataPoint);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__SiteStatsDataPoint, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__SiteStatsDataPoint, &pp), type);
}

SOAP_FMAC3 tns__SiteStatsDataPoint ** SOAP_FMAC4 soap_get_PointerTotns__SiteStatsDataPoint(struct soap *soap, tns__SiteStatsDataPoint **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__SiteStatsDataPoint(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 tns__SiteStatsDataPoint ** SOAP_FMAC4 soap_in_PointerTotns__SiteStatsDataPoint(struct soap *soap, const char *tag, tns__SiteStatsDataPoint **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (tns__SiteStatsDataPoint **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__SiteStatsDataPoint, sizeof(tns__SiteStatsDataPoint *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (tns__SiteStatsDataPoint **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTotns__SiteStatsDataPoint, sizeof(tns__SiteStatsDataPoint *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (tns__SiteStatsDataPoint *)soap_instantiate_tns__SiteStatsDataPoint(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (tns__SiteStatsDataPoint **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__SiteStatsDataPoint, sizeof(tns__SiteStatsDataPoint *), 1), SOAP_TYPE_tns__SiteStatsDataPoint, sizeof(tns__SiteStatsDataPoint), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfGroupObject(struct soap *soap, ArrayOfGroupObject *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerToArrayOfGroupObject))
		soap_mark_PointerToArrayOfGroupObject(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerToArrayOfGroupObject(struct soap *soap, ArrayOfGroupObject *const*a)
{
	if (*a && !soap_array_reference(soap, *a, (struct soap_array*)&(*a)->__ptr, (*a)->__size, SOAP_TYPE_ArrayOfGroupObject))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerToArrayOfGroupObject(struct soap *soap, ArrayOfGroupObject **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfGroupObject(struct soap *soap, ArrayOfGroupObject **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerToArrayOfGroupObject);
	soap_out_PointerToArrayOfGroupObject(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfGroupObject(struct soap *soap, const char *tag, int id, ArrayOfGroupObject *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerToArrayOfGroupObject);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_array_pointer_lookup(soap, *a, (struct soap_array*)&(*a)->__ptr, (*a)->__size, SOAP_TYPE_ArrayOfGroupObject, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ArrayOfGroupObject, &pp), type);
}

SOAP_FMAC3 ArrayOfGroupObject ** SOAP_FMAC4 soap_get_PointerToArrayOfGroupObject(struct soap *soap, ArrayOfGroupObject **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfGroupObject(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOfGroupObject ** SOAP_FMAC4 soap_in_PointerToArrayOfGroupObject(struct soap *soap, const char *tag, ArrayOfGroupObject **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ArrayOfGroupObject **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerToArrayOfGroupObject, sizeof(ArrayOfGroupObject *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ArrayOfGroupObject **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerToArrayOfGroupObject, sizeof(ArrayOfGroupObject *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ArrayOfGroupObject *)soap_instantiate_ArrayOfGroupObject(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ArrayOfGroupObject **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerToArrayOfGroupObject, sizeof(ArrayOfGroupObject *), 1), SOAP_TYPE_ArrayOfGroupObject, sizeof(ArrayOfGroupObject), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__GroupObject(struct soap *soap, tns__GroupObject *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__GroupObject))
		soap_mark_PointerTotns__GroupObject(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTotns__GroupObject(struct soap *soap, tns__GroupObject *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__GroupObject))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTotns__GroupObject(struct soap *soap, tns__GroupObject **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__GroupObject(struct soap *soap, tns__GroupObject **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTotns__GroupObject);
	soap_out_PointerTotns__GroupObject(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__GroupObject(struct soap *soap, const char *tag, int id, tns__GroupObject *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__GroupObject);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__GroupObject, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__GroupObject, &pp), type);
}

SOAP_FMAC3 tns__GroupObject ** SOAP_FMAC4 soap_get_PointerTotns__GroupObject(struct soap *soap, tns__GroupObject **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__GroupObject(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 tns__GroupObject ** SOAP_FMAC4 soap_in_PointerTotns__GroupObject(struct soap *soap, const char *tag, tns__GroupObject **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (tns__GroupObject **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__GroupObject, sizeof(tns__GroupObject *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (tns__GroupObject **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTotns__GroupObject, sizeof(tns__GroupObject *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (tns__GroupObject *)soap_instantiate_tns__GroupObject(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (tns__GroupObject **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__GroupObject, sizeof(tns__GroupObject *), 1), SOAP_TYPE_tns__GroupObject, sizeof(tns__GroupObject), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfSiteStatsDataPoint(struct soap *soap, ArrayOfSiteStatsDataPoint *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerToArrayOfSiteStatsDataPoint))
		soap_mark_PointerToArrayOfSiteStatsDataPoint(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerToArrayOfSiteStatsDataPoint(struct soap *soap, ArrayOfSiteStatsDataPoint *const*a)
{
	if (*a && !soap_array_reference(soap, *a, (struct soap_array*)&(*a)->__ptr, (*a)->__size, SOAP_TYPE_ArrayOfSiteStatsDataPoint))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerToArrayOfSiteStatsDataPoint(struct soap *soap, ArrayOfSiteStatsDataPoint **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfSiteStatsDataPoint(struct soap *soap, ArrayOfSiteStatsDataPoint **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerToArrayOfSiteStatsDataPoint);
	soap_out_PointerToArrayOfSiteStatsDataPoint(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfSiteStatsDataPoint(struct soap *soap, const char *tag, int id, ArrayOfSiteStatsDataPoint *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerToArrayOfSiteStatsDataPoint);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_array_pointer_lookup(soap, *a, (struct soap_array*)&(*a)->__ptr, (*a)->__size, SOAP_TYPE_ArrayOfSiteStatsDataPoint, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ArrayOfSiteStatsDataPoint, &pp), type);
}

SOAP_FMAC3 ArrayOfSiteStatsDataPoint ** SOAP_FMAC4 soap_get_PointerToArrayOfSiteStatsDataPoint(struct soap *soap, ArrayOfSiteStatsDataPoint **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfSiteStatsDataPoint(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOfSiteStatsDataPoint ** SOAP_FMAC4 soap_in_PointerToArrayOfSiteStatsDataPoint(struct soap *soap, const char *tag, ArrayOfSiteStatsDataPoint **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ArrayOfSiteStatsDataPoint **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerToArrayOfSiteStatsDataPoint, sizeof(ArrayOfSiteStatsDataPoint *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ArrayOfSiteStatsDataPoint **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerToArrayOfSiteStatsDataPoint, sizeof(ArrayOfSiteStatsDataPoint *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ArrayOfSiteStatsDataPoint *)soap_instantiate_ArrayOfSiteStatsDataPoint(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ArrayOfSiteStatsDataPoint **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerToArrayOfSiteStatsDataPoint, sizeof(ArrayOfSiteStatsDataPoint *), 1), SOAP_TYPE_ArrayOfSiteStatsDataPoint, sizeof(ArrayOfSiteStatsDataPoint), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__Bug(struct soap *soap, tns__Bug *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__Bug))
		soap_mark_PointerTotns__Bug(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTotns__Bug(struct soap *soap, tns__Bug *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__Bug))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTotns__Bug(struct soap *soap, tns__Bug **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__Bug(struct soap *soap, tns__Bug **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTotns__Bug);
	soap_out_PointerTotns__Bug(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__Bug(struct soap *soap, const char *tag, int id, tns__Bug *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__Bug);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__Bug, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__Bug, &pp), type);
}

SOAP_FMAC3 tns__Bug ** SOAP_FMAC4 soap_get_PointerTotns__Bug(struct soap *soap, tns__Bug **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__Bug(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 tns__Bug ** SOAP_FMAC4 soap_in_PointerTotns__Bug(struct soap *soap, const char *tag, tns__Bug **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (tns__Bug **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__Bug, sizeof(tns__Bug *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (tns__Bug **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTotns__Bug, sizeof(tns__Bug *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (tns__Bug *)soap_instantiate_tns__Bug(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (tns__Bug **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__Bug, sizeof(tns__Bug *), 1), SOAP_TYPE_tns__Bug, sizeof(tns__Bug), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__ArrayOfstring(struct soap *soap, tns__ArrayOfstring *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__ArrayOfstring))
		soap_mark_PointerTotns__ArrayOfstring(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTotns__ArrayOfstring(struct soap *soap, tns__ArrayOfstring *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__ArrayOfstring))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTotns__ArrayOfstring(struct soap *soap, tns__ArrayOfstring **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__ArrayOfstring(struct soap *soap, tns__ArrayOfstring **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTotns__ArrayOfstring);
	soap_out_PointerTotns__ArrayOfstring(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__ArrayOfstring(struct soap *soap, const char *tag, int id, tns__ArrayOfstring *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__ArrayOfstring);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__ArrayOfstring, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__ArrayOfstring, &pp), type);
}

SOAP_FMAC3 tns__ArrayOfstring ** SOAP_FMAC4 soap_get_PointerTotns__ArrayOfstring(struct soap *soap, tns__ArrayOfstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__ArrayOfstring(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 tns__ArrayOfstring ** SOAP_FMAC4 soap_in_PointerTotns__ArrayOfstring(struct soap *soap, const char *tag, tns__ArrayOfstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (tns__ArrayOfstring **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__ArrayOfstring, sizeof(tns__ArrayOfstring *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (tns__ArrayOfstring **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTotns__ArrayOfstring, sizeof(tns__ArrayOfstring *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (tns__ArrayOfstring *)soap_instantiate_tns__ArrayOfstring(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (tns__ArrayOfstring **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__ArrayOfstring, sizeof(tns__ArrayOfstring *), 1), SOAP_TYPE_tns__ArrayOfstring, sizeof(tns__ArrayOfstring), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__string(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsd__string
	*a = SOAP_DEFAULT_xsd__string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__string);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_xsd__string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__string(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_xsd__string);
	soap_out_xsd__string(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__string, 1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__integer(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsd__integer
	*a = SOAP_DEFAULT_xsd__integer;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__integer(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__integer);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_xsd__integer(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__integer);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__integer(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_xsd__integer);
	soap_out_xsd__integer(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__integer(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__integer);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__integer(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__integer(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__integer(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__integer, 1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT__QName
	*a = SOAP_DEFAULT__QName;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE__QName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark__QName(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE__QName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE__QName);
	soap_out__QName(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_string);
	soap_out_string(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1);
}

SOAP_END_NAMESPACE(soap)

/* end of soapC.cpp */
