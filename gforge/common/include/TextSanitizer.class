<?php

/**
 * GForge Text Sanitizer Class
 *
 * 
 *
 * This file is part of GForge.
 *
 * GForge is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * GForge is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GForge; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

/* Text Sanitizer Class
	by Daniel Perez (danielperez.arg@gmail.com) - 2005
*/

require_once('pre.php');


Class TextSanitizer extends Error {
	
		/**
	 *  ProcessAttributeForTag - Helper function. Gets the attribute and if it isn´t " " it does attname=\"attvalue\"
	 *
	 *	@param   string		The attribute name
	 *	@param   string		The attribute value
	 *	@return  string		The attribute to be input in the tag, or blank
	 */	
	function ProcessAttributeForTag($name,$value) {
		if ($value==" ") {
			return " ";
		} else {
			return $name . '=\"' . $value . '\"';
		}
	}
	
		/**
	 *  FindAttribute - Helper function. Finds the attribute in the string and returns it if it doesn´t have any of the notallowed array
	 *
	 *	@param   string		The attribute to find
	 *	@param   string		The string to search
	 *	@param   array		The array containing not allowed substrings
	 *	@return  string		The attribute or "" if it wasn´t found or wasn´t allowed
	 */
	function FindAttribute($name,$string,$notallowed) {
		$attr = " ";
		preg_match('/' . $name . '=\\\\&quot;([^;]*)\\\\&quot;/',$string,$found);
		if ($found[1]) {
			if (!in_array($found[1],$notallowed)) {
				$attr = $found[1];
			}
		}
		return $attr;
	}
	
		/**
	 *  FindExactAttribute - Helper function. Finds the attribute in the string and returns it if it doesn´t have any of the notallowed array and only if it´s in the allowed string
	 *
	 *	@param   string		The attribute to find
	 *	@param   string		The string to search
	 *	@param   array		The array containing not allowed substrings
	 *	@param   array		The array containing allowed substrings
	 *	@return  string		The attribute or "" if it wasn´t found or wasn´t allowed
	 */
	function FindExactAttribute($name,$string,$notallowed,$allowedonly) {
		$attr = " ";
		preg_match('/' . $name . '=\\\\&quot;([^;]*)\\\\&quot;/',$string,$found);
		if ($found[1]) {
			if ( (!in_array($found[1],$notallowed)) && (in_array($found[1],$allowedonly)) ) {
				$attr = $found[1];
			}
		}
		return $attr;
	}
		
	
		/**
	 *  SanitizeHtml - Grabs some text with all kinds of html code and parses it to make it safe
	 *
	 *	@param   string		The HTML Code
	 *	@return  string		The HTML output
	 */
	function SanitizeHtml($input) {
		
	$input = htmlspecialchars($input); // first strip all chars
		
	//to hell with <script> </script> tags
	$script_open = '/(&lt;.*[s|S][c|C][r|R][i|I][p|P][t|T].*&gt;)/';
	$input = preg_replace($script_open,"<b>No script tags of any kind allowed</b>",$input);
		
	//search for <strong>something</strong> . 
		$strong_notok = '/(.*)(&lt;[^&lt;|^&gt;]*[s|S][t|T][r|R][o|O][n|N][g|G][^&lt;|^&gt;]*&gt;)(.*)(&lt;.*\/[s|S][t|T][r|R][o|O][n|N][g|G][^&lt;|^&gt;]*&gt;)(.*)/';
		$input = preg_replace($strong_notok,"$1<strong>$3</strong>$5",$input);
		
	//search for <em>something</em> . 
		$em_notok = '/(.*)(&lt;[^&lt;|^&gt;]*[e|E][m|M][^&lt;|^&gt;]*&gt;)(.*)(&lt;.*\/[e|E][m|M][^&lt;|^&gt;]*&gt;)(.*)/';
		$input = preg_replace($em_notok,"$1<em>$3</em>$5",$input);
		
	//search for <u>something</u> . 
		$u = '/(.*)(&lt;[^&lt;|^&gt;]*[u|U][^&lt;|^&gt;]*&gt;)(.*)(&lt;.*\/[u|U][^&lt;|^&gt;]*&gt;)(.*)/';
		$input = preg_replace($u,"$1<u>$3</u>$5",$input);
		
	//search for <strike>something</strike> . 
		$strike = '/(.*)(&lt;[^&lt;|^&gt;]*[s|S][t|T][r|R][i|I][k|K][e|E][^&lt;|^&gt;]*&gt;)(.*)(&lt;.*\/[s|S][t|T][r|R][i|I][k|K][e|E][^&lt;|^&gt;]*&gt;)(.*)/';
		$input = preg_replace($strike,"$1<strike>$3</strike>$5",$input);			
		
	//search for <sub>something</sub> . 
		$sub = '/(.*)(&lt;[^&lt;|^&gt;]*[s|S][u|U][b|B][^&lt;|^&gt;]*&gt;)(.*)(&lt;.*\/[s|S][u|U][b|B][^&lt;|^&gt;]*&gt;)(.*)/';
		$input = preg_replace($sub,"$1<sub>$3</sub>$5",$input);					

	//search for <sup>something</sup> . 
		$sup = '/(.*)(&lt;[^&lt;|^&gt;]*[s|S][u|U][p|P][^&lt;|^&gt;]*&gt;)(.*)(&lt;.*\/[s|S][u|U][p|P][^&lt;|^&gt;]*&gt;)(.*)/';
		$input = preg_replace($sup,"$1<sup>$3</sup>$5",$input);
		
	//search for <h1>something</h1> . 
		$h1 = '/(.*)(&lt;[^&lt;|^&gt;]*[h|H]1[^&lt;|^&gt;]*&gt;)(.*)(&lt;.*\/[h|H]1[^&lt;|^&gt;]*&gt;)(.*)/';
		$input = preg_replace($h1,"$1<h1>$3</h1>$5",$input);
		
	//search for <h2>something</h2> . 
		$h2 = '/(.*)(&lt;[^&lt;|^&gt;]*[h|H][1][^&lt;|^&gt;]*&gt;)(.*)(&lt;.*\/[h|H][1][^&lt;|^&gt;]*&gt;)(.*)/';
		$input = preg_replace($h2,"$1<h2>$3</h2>$5",$input);

	//search for <h3>something</h3> . 
		$h3 = '/(.*)(&lt;[^&lt;|^&gt;]*[h|H]3[^&lt;|^&gt;]*&gt;)(.*)(&lt;.*\/[h|H]3[^&lt;|^&gt;]*&gt;)(.*)/';
		$input = preg_replace($h3,"$1<h3>$3</h3>$5",$input);

	//search for <h4>something</h4> . 
		$h4 = '/(.*)(&lt;[^&lt;|^&gt;]*[h|H]4[^&lt;|^&gt;]*&gt;)(.*)(&lt;.*\/[h|H]4[^&lt;|^&gt;]*&gt;)(.*)/';
		$input = preg_replace($h4,"$1<h4>$3</h4>$5",$input);

	//search for <h5>something</h5> . 
		$h5 = '/(.*)(&lt;[^&lt;|^&gt;]*[h|H]5[^&lt;|^&gt;]*&gt;)(.*)(&lt;.*\/[h|H]5[^&lt;|^&gt;]*&gt;)(.*)/';
		$input = preg_replace($h5,"$1<h5>$3</h5>$5",$input);

	//search for <h6>something</h6> . 
		$h6 = '/(.*)(&lt;[^&lt;|^&gt;]*[h|H]6[^&lt;|^&gt;]*&gt;)(.*)(&lt;.*\/[h|H]6[^&lt;|^&gt;]*&gt;)(.*)/';
		$input = preg_replace($h6,"$1<h6>$3</h6>$5",$input);
		
	//search for <address>something</address> . 
		$address = '/(.*)(&lt;[^&lt;|^&gt;]*[a|A][d|D][d|D][r|R][e|E][s|S][s|S][^&lt;|^&gt;]*&gt;)(.*)(&lt;.*\/[a|A][d|D][d|D][r|R][e|E][s|S][s|S][^&lt;|^&gt;]*&gt;)(.*)/';
		$input = preg_replace($address,"$1<address>$3</address>$5",$input);
		
	//search for <td>something</td> . 
		$td = '/(.*)(&lt;[^&lt;|^&gt;]*[t|T][d|D][^&lt;|^&gt;]*&gt;)(.*)(&lt;.*\/[t|T][d|D][^&lt;|^&gt;]*&gt;)(.*)/';
		$input = preg_replace($td,"$1<td>$3</td>$5",$input);
		
	//search for <caption>something</caption> . 
		$caption = '/(.*)(&lt;[^&lt;|^&gt;]*[c|C][a|A][p|P][t|T][i|I][o|O][n|N][^&lt;|^&gt;]*&gt;)(.*)(&lt;.*\/[c|C][a|A][p|P][t|T][i|I][o|O][n|N][^&lt;|^&gt;]*&gt;)(.*)/';
		$input = preg_replace($caption,"$1<caption>$3</caption>$5",$input);
	
	//search for <tr>something</tr> . 
		$tr = '/(.*)(&lt;[^&lt;|^&gt;]*[t|T][r|R][^&lt;|^&gt;]*&gt;)(.*)(&lt;.*\/[t|T][r|R][^&lt;|^&gt;]*&gt;)(.*)/ms'; // the ms modifier at the end needed because of newline.
		while (preg_match($tr,$input)) {
			$input = preg_replace($tr,"$1<tr>$3</tr>$5",$input);
		}

	//search for <tbody>something</tbody> . 
		$tbody = '/(.*)(&lt;[^&lt;|^&gt;]*[t|T][b|B][o|O][d|D][y|Y][^&lt;|^&gt;]*&gt;)(.*)(&lt;.*\/[t|T][b|B][o|O][d|D][y|Y][^&lt;|^&gt;]*&gt;)(.*)/ms'; // the ms modifier at the end needed because of newline.
		while (preg_match($tbody,$input)) {
			$input = preg_replace($tbody,"$1<tbody>$3</tbody>$5",$input);
		}
		
	//search for <ol>something</ol> . 
		$ol = '/(.*)(&lt;[^&lt;|^&gt;]*[o|O][l|L][^&lt;|^&gt;]*&gt;)(.*)(&lt;.*\/[o|O][l|L][^&lt;|^&gt;]*&gt;)(.*)/ms'; // the ms modifier at the end needed because of newline.
		while (preg_match($ol,$input)) {
			$input = preg_replace($ol,"$1<ol>$3</ol>$5",$input);
		}
		
	//search for <ul>something</ul> . 
		$ul = '/(.*)(&lt;[^&lt;|^&gt;]*[u|U][l|L][^&lt;|^&gt;]*&gt;)(.*)(&lt;.*\/[u|U][l|L][^&lt;|^&gt;]*&gt;)(.*)/ms'; // the ms modifier at the end needed because of newline.
		while (preg_match($ul,$input)) {
			$input = preg_replace($ul,"$1<ul>$3</ul>$5",$input);
		}
		
	//search for <li>something</li> . 
		$li = '/(.*)(&lt;[^&lt;|^&gt;]*[l|L][i|I][^&lt;|^&gt;]*&gt;)(.*)(&lt;.*\/[l|L][i|I][^&lt;|^&gt;]*&gt;)(.*)/ms'; // the ms modifier at the end needed because of newline.
		while (preg_match($li,$input)) {
			$input = preg_replace($li,"$1<li>$3</li>$5",$input);
		}	
		
	//search for <blockquote>something</blockquote> . 
		$blockquote = '/(.*)(&lt;[^&lt;|^&gt;]*[b|B][l|L][o|O][c|C][k|K][q|Q][u|U][o|O][t|T][e|E][^&lt;|^&gt;]*&gt;)(.*)(&lt;.*\/[b|B][l|L][o|O][c|C][k|K][q|Q][u|U][o|O][t|T][e|E][^&lt;|^&gt;]*&gt;)(.*)/ms'; // the ms modifier at the end needed because of newline.
		while (preg_match($blockquote,$input)) {
			$input = preg_replace($blockquote,"$1<blockquote>$3</blockquote>$5",$input);				
		}
		
	//search for <pre>something</pre> . 
		$pre1 = '/(.*)(&lt;[^&lt;|^&gt;]*[p|P][r|R][e|E][^&lt;|^&gt;]*&gt;)(.*)(&lt;.*\/[p|P][r|R][e|E][^&lt;|^&gt;]*&gt;)(.*)/';
		$pre2 = '/(.*)(&lt;[^&lt;|^&gt;]*[p|P][r|R][e|E][^&lt;|^&gt;]*&gt;)(.*)(&lt;.*\/[p|P][r|R][e|E][^&lt;|^&gt;]*&gt;)(.*)/ms'; // the ms modifier at the end needed because of newline.
		$input = preg_replace($pre1,"$1<pre>$3</pre>$5",$input);
		$input = preg_replace($pre2,"$1<pre>$3</pre>$5",$input);
		
	//search for <p>something</p> . 
		$p = '/(.*)(&lt;[^&lt;|^&gt;]*[p|P][^&lt;|^&gt;]*&gt;)(.*)(&lt;.*\/[p|P][^&lt;|^&gt;]*&gt;)(.*)/';
		$input = preg_replace($p,"$1<p>$3</p>$5",$input);
		
	//search for <p align="something">something</p> 
		$align1 = '/(.*)(&lt;[^&lt;|^&gt;]*[p|P]\s+[a|A][l|L][i|I][g|G][n|N]=\\\\&quot;(.+)\\\\&quot;[^&lt;|^&gt;]*&gt;)(.*)(&lt;.*\/[p|P][^&lt;|^&gt;]*&gt;)(.*)/ms'; // the ms modifier at the end needed because of newline.
		while(preg_match_all($align1,$input,$match,PREG_SET_ORDER)) { // don´t know why but preg_math doesn´t return any coincidence :S. just searching for ONE at a time
				//search for every match if the attributes of the tag is what we expect
				$aligns = array("center","right","left","justify");
				if (in_array($match[0][3],$aligns)) {
					//ok, replace
					$input = str_replace($match[0][2] . $match[0][4] . $match[0][5],"<p align=\"" . $match[0][3] . "\">" . $match[0][4] . "</p>",$input);
				} else {
					//didn´t have what we expected
				}
		}
		unset($matchs);
		
	//search for <div align="something">something</div> 
		$align2 = '/(.*)(&lt;[^&lt;|^&gt;]*[d|D][i|I][v|V]\s+[a|A][l|L][i|I][g|G][n|N]=\\\\&quot;(.+)\\\\&quot;[^&lt;|^&gt;]*&gt;)(.*)(&lt;.*\/[d|D][i|I][v|V][^&lt;|^&gt;]*&gt;)(.*)/ms'; // the ms modifier at the end needed because of newline.
		while(preg_match_all($align2,$input,$match,PREG_SET_ORDER)) { // don´t know why but preg_math doesn´t return any coincidence :S. just searching for ONE at a time
				//search for every match if the attributes of the tag is what we expect
				$aligns = array("center","right","left","justify");
				if (in_array($match[0][3],$aligns)) {
					//ok, replace
					$input = str_replace($match[0][2] . $match[0][4] . $match[0][5],"<div align=\"" . $match[0][3] . "\">" . $match[0][4] . "</div>",$input);
				} else {
					//didn´t have what we expected
				}
		}
		unset($matchs);

	//search for <img PERMITTED/>
		$img = '/(.*)(&lt;[^&lt;|^&gt;]*[i|I][m|M][g|G]\s)(.+)(\/[^&lt;|^&gt;|^a_z]*&gt;)(.*)/';
		preg_match_all($img,$input,$matchs,PREG_SET_ORDER);
		foreach ($matchs as $match) {
			//search for every match to see if the attributes of the tag is NOT what we expect
			$thisone = $match[3]; //we store the attributes of the tag
			
			//don´t allow "<", ">" or "();"  inside attributes
			$notallowed = array("&lt;","&gt;","();"); // we won´t accept things that have "<" or ">" or "();"
 			
			//search for width attribute
			$img_width = $this->FindAttribute("width",$thisone,$notallowed);
			
			//search for vspace attribute
			$img_vspace = $this->FindAttribute("vspace",$thisone,$notallowed);
			
			//search for lang attribute
			$img_lang = $this->FindAttribute("lang",$thisone,$notallowed);
			
			//search for hspace attribute
			$img_hspace = $this->FindAttribute("hspace",$thisone,$notallowed);
			
			//search for height attribute
			$img_height = $this->FindAttribute("height",$thisone,$notallowed);
			
			//search for border attribute
			$img_border = $this->FindAttribute("border",$thisone,$notallowed);
			
			//search for align attribute
			$img_align = $this->FindAttribute("align",$thisone,$notallowed);
			
			//search for src attribute
			$img_src = $this->FindAttribute("src",$thisone,$notallowed);
			
			//search for alt attribute
			$img_alt = $this->FindAttribute("alt",$thisone,$notallowed);
			
			//search for id attribute
			$img_id = $this->FindAttribute("id",$thisone,$notallowed);
			
			//search for title attribute
			$img_title = $this->FindAttribute("title",$thisone,$notallowed);
			
			//search for class attribute
			$img_class = $this->FindAttribute("class",$thisone,$notallowed);
			
			//search for longdesc attribute
			$img_longdesc = $this->FindAttribute("longdesc",$thisone,$notallowed);
			
			//search for style attribute
			$img_style = $this->FindAttribute("style",$thisone,$notallowed);
			
			//finally, replace
			//we have some trouble with images in IE if we pass null to width and height params
			$img_width = $this->ProcessAttributeForTag("width",$img_width);
			$img_height = $this->ProcessAttributeForTag("height",$img_height);
			// the rest. to avoid empty attributes
			$img_vspace = $this->ProcessAttributeForTag("vspace",$img_vspace);
			$img_hspace = $this->ProcessAttributeForTag("hspace",$img_hspace);
			$img_lang = $this->ProcessAttributeForTag("lang",$img_lang);
			$img_border = $this->ProcessAttributeForTag("border",$img_border);
			$img_align = $this->ProcessAttributeForTag("align",$img_align);
			$img_src = $this->ProcessAttributeForTag("src",$img_src);
			$img_id = $this->ProcessAttributeForTag("id",$img_id);
			$img_title = $this->ProcessAttributeForTag("title",$img_title);
			$img_class = $this->ProcessAttributeForTag("class",$img_class);
			$img_longdesc = $this->ProcessAttributeForTag("longdesc",$img_longdesc);
			$img_style = $this->ProcessAttributeForTag("style",$img_style);
			$img_alt = $this->ProcessAttributeForTag("alt",$img_alt);
			
			$input = str_replace($match[2] . $match[3] . $match[4],"<img $img_width $img_vspace $img_lang $img_hspace $img_height $img_border $img_align $img_src $img_alt $img_id $img_title $img_class $img_longdesc $img_style />",$input);
		}
		
		
	//search for <a PERMITTED>something</a>
		
		// i must do a preg_match repeadtely instead of preg_match_all because there may be identical links but some with some text or img between the tags and other without and this would lead to some discarted <a> tags
		$a = '/(.*)(&lt;[^&lt;|^&gt;]*[a|A]\s(.+)[^&lt;|^&gt;]*&gt;)(.*)(&lt;.*\/[a|A][^&lt;|^&gt;]*&gt;)(.*)/';
		preg_match_all($a,$input,$matchs,PREG_SET_ORDER);
		
		while ($matchs) {
		// we re-do the preg_match_all because there can be identical <a> tags but which have different things inside (like one with text, one with an image, etc) and if we don´t do this it makes just one pass and doesn´t work	
			foreach ($matchs as $match) {
				//search for every match to see if the attributes of the tag is NOT what we expect
				$thisone = $match[3]; //we store the attributes of the tag
				
				//don´t allow "<", ">" or "();"  inside attributes
				$notallowed = array("&lt;","&gt;","();"); // we won´t accept things that have "<" or ">" or "();"
				
				//search for lang attr
				$a_language = $this->FindAttribute("lang",$thisone,$notallowed);
							
				//search for href attribute
				$a_href = $this->FindAttribute("href",$thisone,$notallowed);
							
				//search for target attribute
				$allowedonly = array("_blank","_top","_self","_parent"); //don´+t let javascript and stuff go
				$a_target = $this->FindExactAttribute("target",$thisone,$notallowed,$allowedonly);
							
				//search for id attribute
				$a_id = $this->FindAttribute("id",$thisone,$notallowed);
				
				//search for name attribute
				$a_name = $this->FindAttribute("name",$thisone,$notallowed);
				
				//search for accesskey attribute
				$a_accesskey = $this->FindAttribute("accesskey",$thisone,$notallowed);
				
				//search for title attribute
				$a_title = $this->FindAttribute("title",$thisone,$notallowed);
				
				//search for class attribute
				$a_class = $this->FindAttribute("class",$thisone,$notallowed);
				
				//search for type attribute
				$a_type = $this->FindAttribute("type",$thisone,$notallowed);
				
				//search for charset attribute
				$a_charset = $this->FindAttribute("charset",$thisone,$notallowed);
				
				//search for style attribute
				$a_style = $this->FindAttribute("style",$thisone,$notallowed);
				
				// to avoid empty attributes
				$a_language = $this->ProcessAttributeForTag("language",$a_language);
				$a_href = $this->ProcessAttributeForTag("href",$a_href);
				$a_target = $this->ProcessAttributeForTag("target",$a_target);
				$a_id = $this->ProcessAttributeForTag("id",$a_id);
				$a_name = $this->ProcessAttributeForTag("name",$a_name);
				$a_accesskey = $this->ProcessAttributeForTag("accesskey",$a_accesskey);
				$a_title = $this->ProcessAttributeForTag("title",$a_title);
				$a_class = $this->ProcessAttributeForTag("class",$a_class);
				$a_type = $this->ProcessAttributeForTag("type",$a_type);
				$a_charset = $this->ProcessAttributeForTag("charset",$a_charset);
				$a_style = $this->ProcessAttributeForTag("style",$a_style);
				
				//finally, replace
				$input = str_replace($match[2] . $match[4] . $match[5],"<a $a_language $a_href $a_target $a_id $a_name $a_accesskey $a_title $a_class $a_type $a_charset $a_style>" .$match[4] . "</a>",$input);
				
			}
			unset($matchs);
			preg_match_all($a,$input,$matchs,PREG_SET_ORDER);
		}
		
	//search for <font PERMITTED>something</font>
		$font = '/(.*)(&lt;[^&lt;|^&gt;]*[f|F][o|O][n|N][t|T]\s(.+)[^&lt;|^&gt;]*&gt;)(.*)(&lt;.*\/[f|F][o|O][n|N][t|T][^&lt;|^&gt;]*&gt;)(.*)/';
		preg_match_all($font,$input,$matchs,PREG_SET_ORDER);
		foreach ($matchs as $match) {
			//search for every match to see if the attributes of the tag is NOT what we expect
			$thisone = $match[3]; //we store the attributes of the tag
			
			//don´t allow "<", ">" or "();"  inside attributes
			$notallowed = array("&lt;","&gt;","();"); // we won´t accept things that have "<" or ">" or "();"
 			
			//search for size attribute
			$font_size = $this->FindAttribute("size",$thisone,$notallowed);
			
			//search for face attribute
			$allowedonly = array("Comic Sans MS","Arial","Courier New","Tahoma","Times New Roman","Verdana"); //don´+t let javascript and stuff go
			$font_face = $this->FindExactAttribute("face",$thisone,$notallowed,$allowedonly);
			
			//search for color attribute
			$font_color = $this->FindAttribute("color",$thisone,$notallowed);
			
			// to avoid empty attributes
			$font_size = $this->ProcessAttributeForTag("size",$font_size);
			$font_face = $this->ProcessAttributeForTag("face",$font_face);
			$font_color = $this->ProcessAttributeForTag("color",$font_color);
			
			//finally, replace
			$input = str_replace($match[2] . $match[4] . $match[5],"<font $font_size $font_face $font_color>" .$match[4] . "</font>",$input);
		}

	//search for <table PERMITTED>something</table>	
		$table = '/(.*)(&lt;[^&lt;|^&gt;]*[t|T][a|A][b|B][l|L][e|E]\s(.+)[^&lt;|^&gt;]*&gt;)(.*)(&lt;.*\/[t|T][a|A][b|B][l|L][e|E][^&lt;|^&gt;]*&gt;)(.*)/ms';
		preg_match_all($table,$input,$matchs,PREG_SET_ORDER);
		while ($matchs) {
		// we re-do the preg_match_all because there can be identical <a> tags but which have different things inside (like one with text, one with an image, etc) and if we don´t do this it makes just one pass and doesn´t work	
			foreach ($matchs as $match) {
				//search for every match to see if the attributes of the tag is NOT what we expect
				$thisone = $match[3]; //we store the attributes of the tag
				
				//don´t allow "<", ">" or "();"  inside attributes
				$notallowed = array("&lt;","&gt;","();"); // we won´t accept things that have "<" or ">" or "();"
	 			
				//search for width attribute
				$table_width = $this->FindAttribute("width",$thisone,$notallowed);
					
				//search for cellspacing attribute
				$table_cellspacing = $this->FindAttribute("cellspacing",$thisone,$notallowed);
				
				//search for cellpadding attribute
				$table_cellpadding = $this->FindAttribute("cellpadding",$thisone,$notallowed);
				
				//search for border attribute
				$table_border = $this->FindAttribute("border",$thisone,$notallowed);
				
				//search for align attribute
				$table_align = $this->FindAttribute("align",$thisone,$notallowed);
				
				// to avoid empty attributes
				$table_width = $this->ProcessAttributeForTag("width",$table_width);
				$table_cellspacing = $this->ProcessAttributeForTag("cellspacing",$table_cellspacing);
				$table_cellpadding = $this->ProcessAttributeForTag("cellpadding",$table_cellpadding);
				$table_border = $this->ProcessAttributeForTag("border",$table_border);
				$table_align = $this->ProcessAttributeForTag("align",$table_align);
				
				//finally, replace
				$input = str_replace($match[2] . $match[4] . $match[5],"<table $table_width $table_cellspacing $table_cellpadding $table_border $table_align>" .$match[4] . "</table>",$input);
			}
			unset($matchs);
			preg_match_all($table,$input,$matchs,PREG_SET_ORDER);
		}
		
	//search for <hr PERMITTED/>
		$hr = '/(.*)(&lt;[^&lt;|^&gt;]*[h|H][r|R]\s)(.+)(\/[^&lt;|^&gt;|^a_z]*&gt;)(.*)/';
		preg_match_all($hr,$input,$matchs,PREG_SET_ORDER);
		foreach ($matchs as $match) {
			//search for every match to see if the attributes of the tag is NOT what we expect
			$thisone = $match[3]; //we store the attributes of the tag
			
			//don´t allow "<", ">" or "();"  inside attributes
			$notallowed = array("&lt;","&gt;","();"); // we won´t accept things that have "<" or ">" or "();"
 			
			//search for width attribute
			$hr_width = $this->FindAttribute("width",$thisone,$notallowed);
			
			//search for src attribute
			$hr_size = $this->FindAttribute("size",$thisone,$notallowed);
			
			// to avoid empty attributes
			$hr_width = $this->ProcessAttributeForTag("width",$hr_width);
			$hr_size = $this->ProcessAttributeForTag("size",$hr_size);
			
			//finally, replace
			$input = str_replace($match[2] . $match[3] . $match[4],"<hr $hr_width $hr_size />",$input);
		}

	//search for <textarea PERMITTED>something</textarea>
		$textarea = '/(.*)(&lt;[^&lt;|^&gt;]*[t|T][e|E][x|X][t|T][a|A][r|R][e|E][a|A]\s(.+)[^&lt;|^&gt;]*&gt;)(.*)(&lt;.*\/[t|T][e|E][x|X][t|T][a|A][r|R][e|E][a|A][^&lt;|^&gt;]*&gt;)(.*)/';
		preg_match_all($textarea,$input,$matchs,PREG_SET_ORDER);
		foreach ($matchs as $match) {
			//search for every match to see if the attributes of the tag is NOT what we expect
			$thisone = $match[3]; //we store the attributes of the tag
			
			//don´t allow "<", ">" or "();"  inside attributes
			$notallowed = array("&lt;","&gt;","();"); // we won´t accept things that have "<" or ">" or "();"
 			
			//search for rows attribute
			$textarea_rows = $this->FindAttribute("rows",$thisone,$notallowed);
			
			//search for cols attribute
			$textarea_cols = $this->FindAttribute("cols",$thisone,$notallowed);
			
			//search for name attribute
			$textarea_name = $this->FindAttribute("name",$thisone,$notallowed);
			
			// to avoid empty attributes
			$textarea_rows = $this->ProcessAttributeForTag("rows",$textarea_rows);
			$textarea_cols = $this->ProcessAttributeForTag("cols",$textarea_cols);
			$textarea_name = $this->ProcessAttributeForTag("name",$textarea_name);
			
			//finally, replace
			$input = str_replace($match[2] . $match[4] . $match[5],"<textarea $textarea_rows $textarea_cols $textarea_name >" .$match[4] . "</textarea>",$input);
		}
	
	//search for <input PERMITTED/> 
/*		$input_form = '/(.*)(&lt;[^&lt;|^&gt;]*[i|I][n|N][p|P][u|U][t|T]\s)(.+)(\/[^&lt;|^&gt;|^a_z]*&gt;)(.*)/';
		preg_match_all($input_form,$input,$matchs,PREG_SET_ORDER);
		foreach ($matchs as $match) {
			//search for every match to see if the attributes of the tag is NOT what we expect
			$thisone = $match[3]; //we store the attributes of the tag
			
			//don´t allow "<", ">" or "();"  inside attributes
			$notallowed = array("&lt;","&gt;","();"); // we won´t accept things that have "<" or ">" or "();"
 			
			//search for type attribute
			$allowedonly = array("input_form","radio","text");
			$input_form_type = $this->FindExactAttribute("type",$thisone,$notallowed,$allowedonly) ;
			
			//search for name attribute
			$input_form_name = $this->FindAttribute("name",$thisone,$notallowed);

			//search for value attribute
			$input_form_value = $this->FindAttribute("value",$thisone,$notallowed);
			
			//search for checked attribute
			$input_form_checked = $this->FindAttribute("checked",$thisone,$notallowed);
			
			//search for size attribute
			$input_form_size = $this->FindAttribute("size",$thisone,$notallowed);
			
			//search for maxlength attribute
			$input_form_maxlength = $this->FindAttribute("maxlength",$thisone,$notallowed);
			
			// to avoid empty attributes
			$input_form_type = $this->ProcessAttributeForTag("type",$input_form_type);
			$input_form_name = $this->ProcessAttributeForTag("name",$input_form_name);
			$input_form_value = $this->ProcessAttributeForTag("value",$input_form_value);
			$input_form_checked = $this->ProcessAttributeForTag("checked",$input_form_checked);
			$input_form_size = $this->ProcessAttributeForTag("size",$input_form_size);
			$input_form_maxlength = $this->ProcessAttributeForTag("maxlength",$input_form_maxlength);
			
			//finally, replace
			$input = str_replace($match[2] . $match[3] . $match[4],"<input $input_form_type $input_form_name $input_form_value $input_form_checked $input_form_maxlength $input_form_size />",$input);
		}
*/
		
	//search for &nbsp; and let them be
		$nonbreakingspace = '/&amp;nbsp;/';
		$input = preg_replace($nonbreakingspace,"&nbsp;",$input);
		
	//search for &amp; and let them be
		$nonbreakingspace = '/&amp;amp;/';
		$input = preg_replace($nonbreakingspace,"&amp;",$input);
		
	//search for &quot; and let them be
		$nonbreakingspace = '/&amp;quot;/';
		$input = preg_replace($nonbreakingspace,"&quot;",$input);		

	//search for <br /> and let them be
		$br = '/&lt;br\s{0,3}\/&gt;/';
		$input = preg_replace($br,"<br/>",$input);
	
	
		return $input;
	}
}


?>