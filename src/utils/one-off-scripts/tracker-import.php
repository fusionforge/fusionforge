<?php
/*-
 * one-off script to import tracker items (limited)
 *
 * Copyright © 2012, 2013, 2014
 *	Thorsten “mirabilos” Glaser <t.glaser@tarent.de>
 * All rights reserved.
 *
 * This file is part of FusionForge. FusionForge is free software;
 * you can redistribute it and/or modify it under the terms of the
 * GNU General Public License as published by the Free Software
 * Foundation; either version 2 of the Licence, or (at your option)
 * any later version.
 *
 * FusionForge is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with FusionForge; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 *-
 * Edit below; comments inline.  Imports a JSON generated by tracker-export
 * into a tracker, although only a very small part of the data.
 */

require '/usr/share/gforge/common/include/env.inc.php';
require_once $gfcommon."include/pre.php";
require_once $gfcommon.'include/minijson.php';
require_once $gfcommon.'tracker/Artifact.class.php';
require_once $gfcommon.'tracker/ArtifactFile.class.php';
require_once $gfwww.'tracker/include/ArtifactFileHtml.class.php';
require_once $gfcommon.'tracker/ArtifactType.class.php';
require_once $gfwww.'tracker/include/ArtifactTypeHtml.class.php';
require_once $gfwww.'tracker/include/ArtifactHtml.class.php';
require_once $gfcommon.'tracker/ArtifactCanned.class.php';
require_once $gfcommon.'tracker/ArtifactTypeFactory.class.php';

function usage($rc=1) {
	echo "E: Usage: .../tracker-import.php 123 <t_123.json\n" .
	    "N: where 123 is the group_artifact_id of the tracker to append to\n";
	exit($rc);
}

if (count($argv) != 2) {
	usage();
}
$argv0 = array_shift($argv);
$argv1 = array_shift($argv);

if ($argv1 == '-h') {
	usage(0);
}
if (!($trk = util_nat0($argv1))) {
	usage();
}

/* read input and ensure it’s a JSON Array or Object */
$iv = false;
if (!minijson_decode(file_get_contents('php://stdin'), $iv)) {
	echo "E: input is invalid JSON: $iv\n";
	die;
}
if (!is_array($iv)) {
	echo "E: input top-level element is not an Array or Object\n";
	die;
}

/* validate input elements */
define('IT_STR', 1);
define('IT_LST', 2);	// list (Array or Object) of many
define('IT_ARR', 3);	// Object with key/value check
define('IT_NAT', 4);	// ∈ ℕ₀
define('IT_ANY', 5);	// even NULL
define('IP_REQ', 1);
define('IP_OPT', 2);
define('ICK_NO', 1);	// unchecked
define('ICK_SC', 2);	// schema check (only IT_LST[*] and IT_ARR)
define('ICK_FN', 3);	// function (false=bad, true=ok, array=rpl)

/* ICK_FN called with (parent, fieldname, value, IT_*, IP_*); */

/*
 * These are the fields we require in each entry. Note how we only
 * list those we actually import; so, if you change the below code
 * to import more, list them here, too.
 */
$schema_changelog = array(
	array("by",			IT_STR, IP_REQ, ICK_NO, 0),
	array("entrydate",		IT_NAT, IP_REQ, ICK_NO, 0),
	array("field_name",		IT_STR, IP_REQ, ICK_NO, 0),
	array("new_value",		IT_STR, IP_OPT, ICK_NO, 0),
	array("old_value",		IT_STR, IP_REQ, ICK_NO, 0),
    );
$schema_comments = array(
	array("adddate",		IT_NAT, IP_REQ, ICK_NO, 0),
	array("body",			IT_STR, IP_REQ, ICK_NO, 0),
	array("from_email",		IT_STR, IP_REQ, ICK_NO, 0),
	array("from_user",		IT_STR, IP_OPT, ICK_NO, 0),
    );
$schema_extrafields = array(
	array("alias",			IT_STR, IP_OPT, ICK_NO, 0),
	array("type",			IT_NAT, IP_REQ, ICK_NO, 0),
	array("value",			IT_ANY, IP_REQ, ICK_NO, 0),
    );
$schema_votes = array(
	array("votage_percent",		IT_NAT, IP_REQ, ICK_NO, 0),
	array("voters",			IT_NAT, IP_REQ, ICK_NO, 0),
	array("votes",			IT_NAT, IP_REQ, ICK_NO, 0),
    );
$schema_item = array(
	array("_rpl_itempermalink",	IT_STR, IP_REQ, ICK_NO, 0),
	array("_rpl_taskpermalink",	IT_STR, IP_OPT, ICK_NO, 0),	// ignored
	array("_votes",			IT_ARR, IP_OPT, ICK_SC, $schema_votes),
	array("assigned_email",		IT_STR, IP_OPT, ICK_NO, 0),
	array("assigned_realname",	IT_STR, IP_OPT, ICK_NO, 0),
	array("assigned_to",		IT_NAT, IP_OPT, ICK_NO, 0),
	array("assigned_unixname",	IT_STR, IP_OPT, ICK_NO, 0),
	array("close_date",		IT_NAT, IP_OPT, ICK_NO, 0),//…
	array("details",		IT_STR, IP_REQ, ICK_NO, 0),
	array("last_modified_date",	IT_NAT, IP_REQ, ICK_NO, 0),
	array("open_date",		IT_NAT, IP_REQ, ICK_NO, 0),
	array("priority",		IT_NAT, IP_REQ, ICK_NO, 0),
	array("status_id",		IT_NAT, IP_OPT, ICK_NO, 0),//…
	array("status_name",		IT_STR, IP_OPT, ICK_NO, 0),//…
	array("submitted_by",		IT_NAT, IP_REQ, ICK_NO, 0),
	array("submitted_email",	IT_STR, IP_OPT, ICK_NO, 0),
	array("submitted_realname",	IT_STR, IP_OPT, ICK_NO, 0),
	array("submitted_unixname",	IT_STR, IP_REQ, ICK_NO, 0),
	array("summary",		IT_STR, IP_REQ, ICK_NO, 0),
	array("~changelog",		IT_LST, IP_OPT, ICK_SC, $schema_changelog),
	array("~comments",		IT_LST, IP_OPT, ICK_SC, $schema_comments),
	array("~extrafields",		IT_LST, IP_OPT, ICK_SC, $schema_extrafields),
    );

function jsn_check_one($v, $schema, &$errstr, $nested) {
	if (!is_array($v)) {
		$s = "not an Object";
		$in = "";
 jsn_check_false:
		if (!$errstr) {
			/* do not overwrite previous one */
			$errstr = "item " . $nested . " " . ($in ? (
			    ($ip == IP_REQ ? "required" : "optional") .
			    " field " . $in . " ") : "") . "is " . $s;
		}
		return false;
	}
	$rv = array();
	foreach ($schema as $rule) {
		list($in, $it, $ip, $ick, $icfn) = $rule;
		if (!array_key_exists($in, $v)) {
			if ($ip == IP_REQ) {
				$s = "missing";
				goto jsn_check_false;
			}
			/* optional field */
			continue;
		}
		if (($v[$in] === NULL) && ($it != IT_ANY)) {
			$s = "NULL";
			goto jsn_check_move;
		}
		$vv = $v[$in];
		switch ($it) {
		case IT_STR:
			if (is_array($vv)) {
				$s = "not a scalar";
				goto jsn_check_move;
			}
			$vv = "" . $vv;
			break;
		case IT_LST:
			/*
			 * without ICK_SC this can also be an
			 * array of e.g. strings, so we do not
			 * check for array of arrays
			 */
		case IT_ARR:
			/* no other checks if ICK_NO */
			if (!is_array($vv)) {
				$s = "not an array";
				goto jsn_check_move;
			}
			break;
		case IT_NAT:
			if (is_array($vv)) {
				$s = "not a scalar";
				goto jsn_check_move;
			}
			$vv = "" . $vv;
			if (($tmp = util_nat0($vv)) === false) {
				$s = "not a positive-or-zero integer";
				goto jsn_check_move;
			}
			$vv = $tmp;
			break;
		case IT_ANY:
			break;
		default:
			/* someone made a boo-boo editing this script */
			echo "E: internal error: unknown type " .
			    $it . " for " . $nested . "." . $in . "\n";
			die;
		}
		switch ($ick) {
		case ICK_NO:
			$ickres = true;
			break;
		case ICK_SC:
			$s = "failing schema check";
			switch ($it) {
			case IT_ARR:
				$ickres = jsn_check_one($vv, $icfn,
				    $errstr, $nested . "." . $in);
				break;
			case IT_LST:
				$ickres = array();
				foreach ($vv as $ick_k => $ick_v) {
					$icktmp = jsn_check_one($ick_v,
					    $icfn, $errstr, $nested . "." .
					    $in . "[" . $ick_k . "]");
					if ($icktmp === false) {
						$ickres = false;
						break;
					}
					$ickres[$ick_k] =
					    ($icktmp === true) ?
					    $ick_v : $icktmp;
				}
				break;
			default:
				echo "E: internal error: ICK_SC type " .
				    $it . " for " . $nested . "." . $in . "\n";
				die;
			}
			break;
		case ICK_FN:
			$s = "failing user function check";
			$ickres = call_user_func($icfn, $nested,
			    $in, $vv, $it, $ip);
			break;
		default:
			/* someone made a boo-boo editing this script */
			echo "E: internal error: unknown check " .
			    $ick . " for " . $nested . "." . $in . "\n";
			die;
		}
		if ($ickres === false) {
			/* $s set in the switch immediately above */
 jsn_check_move:
			if ($ip == IP_REQ)
				goto jsn_check_false;
			if (!$errstr) {
				/* do not overwrite previous one */
				$errstr = "item " . $nested . " " . ($in ? (
				    ($ip == IP_REQ ? "required" : "optional") .
				    " field " . $in . " ") : "") . "is " . $s;
			}
			echo "W: $errstr\n";
			$errstr = "";
		} else
			$rv[$in] = ($ickres === true) ? $vv : $ickres;
	}
	$em = array();
	foreach ($v as $vk => $vv) {
		if (!array_key_exists($vk, $rv)) {
			/* not yet seen => unknown */
			$em[$vk] = $vv;
		}
	}
	if ($em)
		$rv['~~not-in-schema'] = $em;
	return $rv;
}

function jsn_check($arr, $schema, &$errstr, $nested="") {
	$rv = array();
	if ($nested)
		$nested .= ".";
	foreach ($arr as $k => $v) {
		if (($rv[$k] = jsn_check_one($v, $schema, $errstr,
		    $nested . $k)) === false)
			return false;
	}
	return $rv;
}

$ic = count($iv);
echo "I: $ic tracker items to consider\n";

$xs = "";
$tmp = jsn_check($iv, $schema_item, $xs);
if ($xs) {
	echo "E: $xs\n";
	die;
}
$iv = $tmp;
unset($tmp);
$ic = count($iv);
echo "I: $ic items are syntactically ok\n";

/* begin the import for sure */

session_set_admin();
$now = time();

/* get the Tracker */
$at =& artifactType_get_object($trk);
if (!$at || !is_object($at) || $at->isError()) {
	echo "E: cannot get tracker object\n";
	die;
}

/* absolute minimum needed for creating tracker items in $at */
$extra_fields = array();
if ($at->usesCustomStatuses()) {
	$i = $at->getCustomStatusField();
	$res = db_query_params('SELECT element_id
		FROM artifact_extra_field_elements
		WHERE extra_field_id=$1
		ORDER BY element_pos ASC, element_id ASC
		LIMIT 1 OFFSET 0',
	    array($i));
	$extra_fields[$i] = db_result($res, 0, 'element_id');
}

/* now import the items, one by one */

$i = 0;
db_begin();
foreach ($iv as $k => $v) {
	echo "I: importing $k (" . ++$i . "/$ic)\n";
	$importData = array();
	$missingData = array();
	if (isset($v["~~not-in-schema"]))
		$missingData['unrecognised JSON slots'] = $v["~~not-in-schema"];
	if (isset($v["_votes"]))
		$missingData['votes'] = $v["_votes"]["votes"] . "/" .
		    $v["_votes"]["voters"] . " (" .
		    $v["_votes"]["votage_percent"] . "%)";
	if ((isset($v["assigned_email"]) || isset($v["assigned_realname"]) ||
	    isset($v["assigned_to"]) || isset($v["assigned_unixname"])) &&
	    (!isset($v["assigned_to"]) || ($v["assigned_to"] != 100)) &&
	    util_ifsetor($v["assigned_realname"]) != "Nobody" &&
	    util_ifsetor($v["assigned_unixname"]) != "None") {
		$missingData['assignee'] = array();
		if (isset($v["assigned_email"]))
			$missingData['assignee']['email'] = $v["assigned_email"];
		if (isset($v["assigned_realname"]))
			$missingData['assignee']['realname'] = $v["assigned_realname"];
		if (isset($v["assigned_to"]))
			$missingData['assignee']['uid'] = $v["assigned_to"];
		if (isset($v["assigned_unixname"]))
			$missingData['assignee']['unixname'] = $v["assigned_unixname"];
	}
	$missingData['status'] = array();
	if (isset($v["close_date"]))
		$missingData['status']['close date'] = $v["close_date"];
	if (isset($v["status_id"]) || isset($v["status_name"])) {
		$missingData['status']['forge'] = array();
		if (isset($v["status_id"]))
			$missingData['status']['forge']['mapping'] =
			    $v["status_id"];
		if (isset($v["status_name"]))
			$missingData['status']['forge']['status'] =
			    $v["status_name"];
	}
	if (isset($v["~extrafields"])) {
		/* for now */
		$missingData['extrafields'] = $v["~extrafields"];
		/* search for custom status */
		$fe = false;
		foreach ($missingData['extrafields'] as $fn => $tmp) {
			if ($tmp["type"] == 7) {
				$fe = $fn;
				break;
			}
		}
		if ($fe) {
			$tmp = $missingData['extrafields'][$fe];
			$missingData['status']['user'] = array(
				'field' => $fe,
				'status' => $tmp["value"],
			    );
			if (isset($tmp["alias"]))
				$missingData['status']['user']['alias'] =
				    $tmp["alias"];
			unset($missingData['extrafields'][$fe]);
		}
	}
	if (!$missingData['status'])
		unset($missingData['status']);

	/* get all standard data fields (we use) */

	$summary = $v["summary"];
	$details = $v["details"];
	/* assign to Nobody by default */
	$assigned_to = 100;
	$priority = $v["priority"];
	$importData['time'] = (int)$v["open_date"];

	/* take over the submitter, but only if they exist */
	if ($v["submitted_by"] != 100 && ($submitter =
	    user_get_object_by_name($v["submitted_unixname"])) &&
	    is_object($submitter) && !($submitter->isError())) {
		/* map the unixname of the submitter to our local user */
		$importData['user'] = $submitter->getID();
	} elseif (($submitter =
	    user_get_object_by_email($v["submitted_email"])) &&
	    is_object($submitter) && !($submitter->isError())) {
		/* map the eMail address of the submitter to our local user */
		$importData['user'] = $submitter->getID();
	} else {
		$submitter = false;
		/* submitted by Nobody */
		$importData['user'] = 100;
	}
	/* store away original data of submitter */
	$missingData['submitter'] = array(
		'uid' => $v["submitted_by"],
		'email' => $v["submitted_email"],
		'realname' => $v["submitted_realname"],
		'unixname' => $v["submitted_unixname"],
	    );
	if ($submitter !== false) {
		/* compare original and new data */
		if ($missingData['submitter']['uid'] == $submitter->getID())
			unset($missingData['submitter']['uid']);
		if ($missingData['submitter']['email'] == $submitter->getEmail())
			unset($missingData['submitter']['email']);
		if ($missingData['submitter']['realname'] == $submitter->getRealName())
			unset($missingData['submitter']['realname']);
		if ($missingData['submitter']['unixname'] == $submitter->getUnixName())
			unset($missingData['submitter']['unixname']);
		/* all equal? */
		if (!$missingData['submitter'])
			unset($missingData['submitter']);
	}

	/* prepend the old permalink in front of the details */
	$old_permalink = str_replace('#', sprintf('%d', $k),
	    $v["_rpl_itempermalink"]);
	$details = "Imported from: " . $old_permalink . "\n\n" . $details;

	/* instantiate a new item */
	$ah = new Artifact($at);
	if (!$ah || !is_object($ah) || $ah->isError()) {
		echo "E: cannot get the object\n";
		db_rollback();
		die;
	}

	/* actually create the item */
	if (!$ah->create($summary, $details, $assigned_to, $priority,
	    $extra_fields, $importData)) {
		echo "E: cannot import: " . $ah->getErrorMessage() . "\n";
		db_rollback();
		die;
	}

	/* import comments */
	if (isset($v["~comments"])) {
		foreach ($v["~comments"] as $tmp) {
			$fe = $tmp["from_email"];
			$fu = util_ifsetor($tmp["from_user"], "");
			if (isset($tmp["from_user"]) &&
			    ($tu = user_get_object_by_name($fu)) &&
			    is_object($tu) && !($tu->isError())) {
				/* nothing */;
			} elseif (($tu =
			    user_get_object_by_email($fe)) &&
			    is_object($tu) && !($tu->isError())) {
				/* nothing */;
			} else
				$tu = false;
			if ($tu) {
				if ($tu->getEmail() == $fe)
					$fe = "";
				if ($tu->getUnixName() == $fu)
					$fu = "";
				$fi = $tu->getID();
			} else
				$fi = 100;
			if ($fe || $fu) {
				$fb = "Originally submitted by ";
				if ($fu)
					$fb .= $fu . " ";
				if ($fe)
					$fb .= "<" . $fe . ">";
				$fb .= "\n\n";
			} else
				$fb = "";
			if (!db_query_params('INSERT INTO artifact_message
				(artifact_id,submitted_by,from_email,adddate,body)
				VALUES ($1,$2,$3,$4,$5)',
			    array(
				$ah->getID(),
				$fi,
				($tu ? $tu->getEmail() : $tmp["from_email"]),
				$tmp["adddate"],
				htmlspecialchars($fb . $tmp["body"]),
			    ))) {
				echo "E: cannot add comment: " .
				    db_error() . "\n";
				db_rollback();
				die;
			}
		}
	}

	/* import changelogs */
	if (isset($v["~changelog"])) {
		foreach ($v["~changelog"] as $tmp) {
			$importData = array();
			$importData['time'] = (int)$tmp["entrydate"];
			if (($tu = user_get_object_by_name($tmp["by"])) &&
			    is_object($tu) && !($tu->isError())) {
				$importData['user'] = $tu->getID();
			} else {
				$importData['user'] = 100;
			}
			if (!$ah->addHistory($tmp["field_name"],
			    $tmp["old_value"],
			    util_ifsetor($tmp["new_value"], ""),
			    $importData)) {
				echo "E: cannot add history entry: " .
				    db_error() . "\n";
				db_rollback();
				die;
			}
		}
	}

	/* note import fallout */
	if ($missingData && !($ah->addMessage('"Lost data importing from ' .
	    $old_permalink . "\" =\t" . minijson_encode($missingData)))) {
		echo "E: cannot add message: " . $ah->getErrorMessage() .
		    " / " . db_error() . "\n";
		db_rollback();
		die;
	}

	/* log the import action */
	if (!$ah->addHistory("-last-modified-then-import",
	    date('Y-m-d H:i:s', $v["last_modified_date"]),
	    date('Y-m-d H:i:s', $now))) {
		echo "E: cannot seal history entry: " . db_error() . "\n";
		db_rollback();
		die;
	}
	if (!db_query_params('UPDATE artifact
		SET last_modified_date=$2
		WHERE artifact_id=$1',
	    array(
		$ah->getID(),
		$now,
	    ))) {
		echo "E: cannot seal entry mtime: " . db_error() . "\n";
		db_rollback();
		die;
	}
	echo "D: imported $k as " . $ah->getID() . "\n";
}
db_commit();
echo "I: done\n";
